(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("node-fetch"));
	else if(typeof define === 'function' && define.amd)
		define(["node-fetch"], factory);
	else if(typeof exports === 'object')
		exports["GeoRaster"] = factory(require("node-fetch"));
	else
		root["GeoRaster"] = factory(root["node-fetch"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_node_fetch__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/cross-fetch/dist/node-ponyfill.js":
/*!********************************************************!*\
  !*** ./node_modules/cross-fetch/dist/node-ponyfill.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var nodeFetch = __webpack_require__(/*! node-fetch */ \"node-fetch\")\nvar realFetch = nodeFetch.default || nodeFetch\n\nvar fetch = function (url, options) {\n  // Support schemaless URIs on the server for parity with the browser.\n  // Ex: //github.com/ -> https://github.com/\n  if (/^\\/\\//.test(url)) {\n    url = 'https:' + url\n  }\n  return realFetch.call(this, url, options)\n}\n\nmodule.exports = exports = fetch\nexports.fetch = fetch\nexports.Headers = nodeFetch.Headers\nexports.Request = nodeFetch.Request\nexports.Response = nodeFetch.Response\n\n// Needed for TypeScript consumers without esModuleInterop.\nexports.default = fetch\n\n\n//# sourceURL=webpack://GeoRaster/./node_modules/cross-fetch/dist/node-ponyfill.js?");

/***/ }),

/***/ "./node_modules/georaster-to-canvas/index.js":
/*!***************************************************!*\
  !*** ./node_modules/georaster-to-canvas/index.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return toCanvas; });\n/* global ImageData */\n\nfunction toImageData(georaster, canvasWidth, canvasHeight) {\n  if (georaster.values) {\n    const { noDataValue, mins, ranges, values } = georaster;\n    const numBands = values.length;\n    const xRatio = georaster.width / canvasWidth;\n    const yRatio = georaster.height / canvasHeight;\n    const data = new Uint8ClampedArray(canvasWidth * canvasHeight * 4);\n    for (let rowIndex = 0; rowIndex < canvasHeight; rowIndex++) {\n      for (let columnIndex = 0; columnIndex < canvasWidth; columnIndex++) {\n        const rasterRowIndex = Math.round(rowIndex * yRatio);\n        const rasterColumnIndex = Math.round(columnIndex * xRatio);\n        const pixelValues = values.map(band => {\n          try {\n            return band[rasterRowIndex][rasterColumnIndex];\n          } catch (error) {\n            console.error(error);\n          }\n        });\n        const haveDataForAllBands = pixelValues.every(value => value !== undefined && value !== noDataValue);\n        if (haveDataForAllBands) {\n          const i = (rowIndex * (canvasWidth * 4)) + 4 * columnIndex;\n          if (numBands === 1) {\n            const pixelValue = Math.round(pixelValues[0]);\n            const scaledPixelValue = Math.round((pixelValue - mins[0]) / ranges[0] * 255);\n            data[i] = scaledPixelValue;\n            data[i + 1] = scaledPixelValue;\n            data[i + 2] = scaledPixelValue;\n            data[i + 3] = 255;\n          } else if (numBands === 3) {\n            try {\n              const [r, g, b] = pixelValues;\n              data[i] = r;\n              data[i + 1] = g;\n              data[i + 2] = b;\n              data[i + 3] = 255;\n            } catch (error) {\n              console.error(error);\n            }\n          } else if (numBands === 4) {\n            try {\n              const [r, g, b, a] = pixelValues;\n              data[i] = r;\n              data[i + 1] = g;\n              data[i + 2] = b;\n              data[i + 3] = a;\n            } catch (error) {\n              console.error(error);\n            }\n          }\n        }\n      }\n    }\n    return new ImageData(data, canvasWidth, canvasHeight);\n  }\n}\n\nfunction toCanvas(georaster, options) {\n  if (typeof ImageData === \"undefined\") {\n    throw `toCanvas is not supported in your environment`;\n  } else {\n    const canvas = document.createElement(\"CANVAS\");\n    const canvasHeight = options && options.height ? Math.min(georaster.height, options.height) : Math.min(georaster.height, 100);\n    const canvasWidth = options && options.width ? Math.min(georaster.width, options.width) : Math.min(georaster.width, 100);\n    canvas.height = canvasHeight;\n    canvas.width = canvasWidth;\n    canvas.style.minHeight = \"200px\";\n    canvas.style.minWidth = \"400px\";\n    canvas.style.maxWidth = \"100%\";\n    const context = canvas.getContext(\"2d\");\n    const imageData = toImageData(georaster, canvasWidth, canvasHeight);\n    context.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n}\n\n\n\n//# sourceURL=webpack://GeoRaster/./node_modules/georaster-to-canvas/index.js?");

/***/ }),

/***/ "./node_modules/geotiff/dist-node sync recursive":
/*!*********************************************!*\
  !*** ./node_modules/geotiff/dist-node sync ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"./node_modules/geotiff/dist-node sync recursive\";\n\n//# sourceURL=webpack://GeoRaster/./node_modules/geotiff/dist-node_sync?");

/***/ }),

/***/ "./node_modules/geotiff/dist-node/main.js":
/*!************************************************!*\
  !*** ./node_modules/geotiff/dist-node/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var require;parcelRequire=function(e,r,t,n){var i,o=\"function\"==typeof parcelRequire&&parcelRequire,u=\"function\"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i=\"function\"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if( true&&\"string\"==typeof t)return __webpack_require__(\"./node_modules/geotiff/dist-node sync recursive\")(t);var c=new Error(\"Cannot find module '\"+t+\"'\");throw c.code=\"MODULE_NOT_FOUND\",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]); true?module.exports=l:undefined}if(parcelRequire=f,i)throw i;return f}({\"j27V\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.geoKeys=exports.geoKeyNames=exports.ExtraSamplesValues=exports.photometricInterpretations=exports.fieldTypes=exports.fieldTypeNames=exports.arrayFields=exports.fieldTagTypes=exports.fieldTags=exports.fieldTagNames=void 0;const e={315:\"Artist\",258:\"BitsPerSample\",265:\"CellLength\",264:\"CellWidth\",320:\"ColorMap\",259:\"Compression\",33432:\"Copyright\",306:\"DateTime\",338:\"ExtraSamples\",266:\"FillOrder\",289:\"FreeByteCounts\",288:\"FreeOffsets\",291:\"GrayResponseCurve\",290:\"GrayResponseUnit\",316:\"HostComputer\",270:\"ImageDescription\",257:\"ImageLength\",256:\"ImageWidth\",271:\"Make\",281:\"MaxSampleValue\",280:\"MinSampleValue\",272:\"Model\",254:\"NewSubfileType\",274:\"Orientation\",262:\"PhotometricInterpretation\",284:\"PlanarConfiguration\",296:\"ResolutionUnit\",278:\"RowsPerStrip\",277:\"SamplesPerPixel\",305:\"Software\",279:\"StripByteCounts\",273:\"StripOffsets\",255:\"SubfileType\",263:\"Threshholding\",282:\"XResolution\",283:\"YResolution\",326:\"BadFaxLines\",327:\"CleanFaxData\",343:\"ClipPath\",328:\"ConsecutiveBadFaxLines\",433:\"Decode\",434:\"DefaultImageColor\",269:\"DocumentName\",336:\"DotRange\",321:\"HalftoneHints\",346:\"Indexed\",347:\"JPEGTables\",285:\"PageName\",297:\"PageNumber\",317:\"Predictor\",319:\"PrimaryChromaticities\",532:\"ReferenceBlackWhite\",339:\"SampleFormat\",340:\"SMinSampleValue\",341:\"SMaxSampleValue\",559:\"StripRowCounts\",330:\"SubIFDs\",292:\"T4Options\",293:\"T6Options\",325:\"TileByteCounts\",323:\"TileLength\",324:\"TileOffsets\",322:\"TileWidth\",301:\"TransferFunction\",318:\"WhitePoint\",344:\"XClipPathUnits\",286:\"XPosition\",529:\"YCbCrCoefficients\",531:\"YCbCrPositioning\",530:\"YCbCrSubSampling\",345:\"YClipPathUnits\",287:\"YPosition\",37378:\"ApertureValue\",40961:\"ColorSpace\",36868:\"DateTimeDigitized\",36867:\"DateTimeOriginal\",34665:\"Exif IFD\",36864:\"ExifVersion\",33434:\"ExposureTime\",41728:\"FileSource\",37385:\"Flash\",40960:\"FlashpixVersion\",33437:\"FNumber\",42016:\"ImageUniqueID\",37384:\"LightSource\",37500:\"MakerNote\",37377:\"ShutterSpeedValue\",37510:\"UserComment\",33723:\"IPTC\",34675:\"ICC Profile\",700:\"XMP\",42112:\"GDAL_METADATA\",42113:\"GDAL_NODATA\",34377:\"Photoshop\",33550:\"ModelPixelScale\",33922:\"ModelTiepoint\",34264:\"ModelTransformation\",34735:\"GeoKeyDirectory\",34736:\"GeoDoubleParams\",34737:\"GeoAsciiParams\"};exports.fieldTagNames=e;const o={};exports.fieldTags=o;for(const G in e)e.hasOwnProperty(G)&&(o[e[G]]=parseInt(G,10));const t={256:\"SHORT\",257:\"SHORT\",258:\"SHORT\",259:\"SHORT\",262:\"SHORT\",273:\"LONG\",274:\"SHORT\",277:\"SHORT\",278:\"LONG\",279:\"LONG\",282:\"RATIONAL\",283:\"RATIONAL\",284:\"SHORT\",286:\"SHORT\",287:\"RATIONAL\",296:\"SHORT\",305:\"ASCII\",306:\"ASCII\",338:\"SHORT\",339:\"SHORT\",513:\"LONG\",514:\"LONG\",1024:\"SHORT\",1025:\"SHORT\",2048:\"SHORT\",2049:\"ASCII\",33550:\"DOUBLE\",33922:\"DOUBLE\",34665:\"LONG\",34735:\"SHORT\",34737:\"ASCII\",42113:\"ASCII\"};exports.fieldTagTypes=t;const i=[o.BitsPerSample,o.ExtraSamples,o.SampleFormat,o.StripByteCounts,o.StripOffsets,o.StripRowCounts,o.TileByteCounts,o.TileOffsets];exports.arrayFields=i;const r={1:\"BYTE\",2:\"ASCII\",3:\"SHORT\",4:\"LONG\",5:\"RATIONAL\",6:\"SBYTE\",7:\"UNDEFINED\",8:\"SSHORT\",9:\"SLONG\",10:\"SRATIONAL\",11:\"FLOAT\",12:\"DOUBLE\",13:\"IFD\",16:\"LONG8\",17:\"SLONG8\",18:\"IFD8\"};exports.fieldTypeNames=r;const a={};exports.fieldTypes=a;for(const G in r)r.hasOwnProperty(G)&&(a[r[G]]=parseInt(G,10));const s={WhiteIsZero:0,BlackIsZero:1,RGB:2,Palette:3,TransparencyMask:4,CMYK:5,YCbCr:6,CIELab:8,ICCLab:9};exports.photometricInterpretations=s;const n={Unspecified:0,Assocalpha:1,Unassalpha:2};exports.ExtraSamplesValues=n;const l={1024:\"GTModelTypeGeoKey\",1025:\"GTRasterTypeGeoKey\",1026:\"GTCitationGeoKey\",2048:\"GeographicTypeGeoKey\",2049:\"GeogCitationGeoKey\",2050:\"GeogGeodeticDatumGeoKey\",2051:\"GeogPrimeMeridianGeoKey\",2052:\"GeogLinearUnitsGeoKey\",2053:\"GeogLinearUnitSizeGeoKey\",2054:\"GeogAngularUnitsGeoKey\",2055:\"GeogAngularUnitSizeGeoKey\",2056:\"GeogEllipsoidGeoKey\",2057:\"GeogSemiMajorAxisGeoKey\",2058:\"GeogSemiMinorAxisGeoKey\",2059:\"GeogInvFlatteningGeoKey\",2060:\"GeogAzimuthUnitsGeoKey\",2061:\"GeogPrimeMeridianLongGeoKey\",2062:\"GeogTOWGS84GeoKey\",3072:\"ProjectedCSTypeGeoKey\",3073:\"PCSCitationGeoKey\",3074:\"ProjectionGeoKey\",3075:\"ProjCoordTransGeoKey\",3076:\"ProjLinearUnitsGeoKey\",3077:\"ProjLinearUnitSizeGeoKey\",3078:\"ProjStdParallel1GeoKey\",3079:\"ProjStdParallel2GeoKey\",3080:\"ProjNatOriginLongGeoKey\",3081:\"ProjNatOriginLatGeoKey\",3082:\"ProjFalseEastingGeoKey\",3083:\"ProjFalseNorthingGeoKey\",3084:\"ProjFalseOriginLongGeoKey\",3085:\"ProjFalseOriginLatGeoKey\",3086:\"ProjFalseOriginEastingGeoKey\",3087:\"ProjFalseOriginNorthingGeoKey\",3088:\"ProjCenterLongGeoKey\",3089:\"ProjCenterLatGeoKey\",3090:\"ProjCenterEastingGeoKey\",3091:\"ProjCenterNorthingGeoKey\",3092:\"ProjScaleAtNatOriginGeoKey\",3093:\"ProjScaleAtCenterGeoKey\",3094:\"ProjAzimuthAngleGeoKey\",3095:\"ProjStraightVertPoleLongGeoKey\",3096:\"ProjRectifiedGridAngleGeoKey\",4096:\"VerticalCSTypeGeoKey\",4097:\"VerticalCitationGeoKey\",4098:\"VerticalDatumGeoKey\",4099:\"VerticalUnitsGeoKey\"};exports.geoKeyNames=l;const p={};exports.geoKeys=p;for(const G in l)l.hasOwnProperty(G)&&(p[l[G]]=parseInt(G,10));\n},{}],\"fpBl\":[function(require,module,exports) {\n\"use strict\";function t(t,e){const{width:n,height:r}=t,o=new Uint8Array(n*r*3);let h;for(let i=0,l=0;i<t.length;++i,l+=3)h=256-t[i]/e*256,o[l]=h,o[l+1]=h,o[l+2]=h;return o}function e(t,e){const{width:n,height:r}=t,o=new Uint8Array(n*r*3);let h;for(let i=0,l=0;i<t.length;++i,l+=3)h=t[i]/e*256,o[l]=h,o[l+1]=h,o[l+2]=h;return o}function n(t,e){const{width:n,height:r}=t,o=new Uint8Array(n*r*3),h=e.length/3,i=e.length/3*2;for(let l=0,s=0;l<t.length;++l,s+=3){const n=t[l];o[s]=e[n]/65536*256,o[s+1]=e[n+h]/65536*256,o[s+2]=e[n+i]/65536*256}return o}function r(t){const{width:e,height:n}=t,r=new Uint8Array(e*n*3);for(let o=0,h=0;o<t.length;o+=4,h+=3){const e=t[o],n=t[o+1],i=t[o+2],l=t[o+3];r[h]=(255-e)/256*255*((255-l)/256),r[h+1]=(255-n)/256*255*((255-l)/256),r[h+2]=(255-i)/256*255*((255-l)/256)}return r}function o(t){const{width:e,height:n}=t,r=new Uint8ClampedArray(e*n*3);for(let o=0,h=0;o<t.length;o+=3,h+=3){const e=t[o],n=t[o+1],i=t[o+2];r[h]=e+1.402*(i-128),r[h+1]=e-.34414*(n-128)-.71414*(i-128),r[h+2]=e+1.772*(n-128)}return r}Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.fromWhiteIsZero=t,exports.fromBlackIsZero=e,exports.fromPalette=n,exports.fromCMYK=r,exports.fromYCbCr=o,exports.fromCIELab=s;const h=.95047,i=1,l=1.08883;function s(t){const{width:e,height:n}=t,r=new Uint8Array(e*n*3);for(let o=0,s=0;o<t.length;o+=3,s+=3){let e,n,a,c=(t[o+0]+16)/116,f=(t[o+1]<<24>>24)/500+c,u=c-(t[o+2]<<24>>24)/200;e=(e=3.2406*(f=h*(f*f*f>.008856?f*f*f:(f-16/116)/7.787))+-1.5372*(c=i*(c*c*c>.008856?c*c*c:(c-16/116)/7.787))+-.4986*(u=l*(u*u*u>.008856?u*u*u:(u-16/116)/7.787)))>.0031308?1.055*e**(1/2.4)-.055:12.92*e,n=(n=-.9689*f+1.8758*c+.0415*u)>.0031308?1.055*n**(1/2.4)-.055:12.92*n,a=(a=.0557*f+-.204*c+1.057*u)>.0031308?1.055*a**(1/2.4)-.055:12.92*a,r[s]=255*Math.max(0,Math.min(1,e)),r[s+1]=255*Math.max(0,Math.min(1,n)),r[s+2]=255*Math.max(0,Math.min(1,a))}return r}\n},{}],\"IKSA\":[function(require,module,exports) {\n\"use strict\";function e(e,t){let r=e.length-t,o=0;do{for(let r=t;r>0;r--)e[o+t]+=e[o],o++;r-=t}while(r>0)}function t(e,t,r){let o=0,n=e.length;const i=n/r;for(;n>t;){for(let r=t;r>0;--r)e[o+t]+=e[o],++o;n-=t}const l=e.slice();for(let s=0;s<i;++s)for(let t=0;t<r;++t)e[r*s+t]=l[(r-t-1)*i+s]}function r(r,o,n,i,l,s){if(!o||1===o)return r;for(let e=0;e<l.length;++e){if(l[e]%8!=0)throw new Error(\"When decoding with predictor, only multiple of 8 bits are supported.\");if(l[e]!==l[0])throw new Error(\"When decoding with predictor, all samples must have the same size.\")}const a=l[0]/8,c=2===s?1:l.length;for(let f=0;f<i&&!(f*c*n*a>=r.byteLength);++f){let i;if(2===o){switch(l[0]){case 8:i=new Uint8Array(r,f*c*n*a,c*n*a);break;case 16:i=new Uint16Array(r,f*c*n*a,c*n*a/2);break;case 32:i=new Uint32Array(r,f*c*n*a,c*n*a/4);break;default:throw new Error(`Predictor 2 not allowed with ${l[0]} bits per sample.`)}e(i,c,a)}else 3===o&&t(i=new Uint8Array(r,f*c*n*a,c*n*a),c,a)}return r}Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.applyPredictor=r;\n},{}],\"FJDe\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.default=void 0;var e=require(\"../predictor\");class t{decode(t,r){const i=this.decodeBlock(r),o=t.Predictor||1;if(1!==o){const r=!t.StripOffsets,s=r?t.TileWidth:t.ImageWidth,d=r?t.TileLength:t.RowsPerStrip||t.ImageLength;return(0,e.applyPredictor)(i,o,s,d,t.BitsPerSample,t.PlanarConfiguration)}return i}}exports.default=t;\n},{\"../predictor\":\"IKSA\"}],\"V9bQ\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.default=void 0;var e=t(require(\"./basedecoder\"));function t(e){return e&&e.__esModule?e:{default:e}}class r extends e.default{decodeBlock(e){return e}}exports.default=r;\n},{\"./basedecoder\":\"FJDe\"}],\"tcId\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.default=void 0;var e=t(require(\"./basedecoder\"));function t(e){return e&&e.__esModule?e:{default:e}}const n=9,r=256,o=257,f=12;function i(e,t,n){const r=t%8,f=Math.floor(t/8),i=8-r,u=t+n-8*(f+1);let c=8*(f+2)-(t+n);const s=8*(f+2)-t;if(c=Math.max(0,c),f>=e.length)return console.warn(\"ran off the end of the buffer before finding EOI_CODE (end on input code)\"),o;let l=e[f]&2**(8-r)-1,a=l<<=n-i;if(f+1<e.length){let t=e[f+1]>>>c;a+=t<<=Math.max(0,n-s)}if(u>8&&f+2<e.length){const r=8*(f+3)-(t+n);a+=e[f+2]>>>r}return a}function u(e,t){for(let n=t.length-1;n>=0;n--)e.push(t[n]);return e}function c(e){const t=new Uint16Array(4093),c=new Uint8Array(4093);for(let n=0;n<=257;n++)t[n]=4096,c[n]=n;let s=258,l=n,a=0;function d(){s=258,l=n}function h(e){const t=i(e,a,l);return a+=l,t}function p(e,n){return c[s]=n,t[s]=e,++s-1}function g(e){const n=[];for(let r=e;4096!==r;r=t[r])n.push(c[r]);return n}const w=[];d();const y=new Uint8Array(e);let b,x=h(y);for(;x!==o;){if(x===r){for(d(),x=h(y);x===r;)x=h(y);if(x===o)break;if(x>r)throw new Error(`corrupted code at scanline ${x}`);u(w,g(x)),b=x}else if(x<s){const e=g(x);u(w,e),p(b,e[e.length-1]),b=x}else{const e=g(b);if(!e)throw new Error(`Bogus entry. Not in dictionary, ${b} / ${s}, position: ${a}`);u(w,e),w.push(e[e.length-1]),p(b,e[e.length-1]),b=x}s+1>=2**l&&(l===f?b=void 0:l++),x=h(y)}return new Uint8Array(w)}class s extends e.default{decodeBlock(e){return c(e,!1).buffer}}exports.default=s;\n},{\"./basedecoder\":\"FJDe\"}],\"J7kk\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.default=void 0;var e=n(require(\"./basedecoder\"));function n(e){return e&&e.__esModule?e:{default:e}}const t=new Int32Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]),r=4017,s=799,o=3406,a=2276,c=1567,i=3784,l=5793,f=2896;function u(e,n){let t=0;const r=[];let s=16;for(;s>0&&!e[s-1];)--s;r.push({children:[],index:0});let o,a=r[0];for(let c=0;c<s;c++){for(let s=0;s<e[c];s++){for((a=r.pop()).children[a.index]=n[t];a.index>0;)a=r.pop();for(a.index++,r.push(a);r.length<=c;)r.push(o={children:[],index:0}),a.children[a.index]=o.children,a=o;t++}c+1<s&&(r.push(o={children:[],index:0}),a.children[a.index]=o.children,a=o)}return r[0].children}function h(e,n,r,s,o,a,c,i,l){const{mcusPerLine:f,progressive:u}=r,h=n;let m=n,d=0,b=0;function p(){if(b>0)return d>>--b&1;if(255===(d=e[m++])){const n=e[m++];if(n)throw new Error(`unexpected marker: ${(d<<8|n).toString(16)}`)}return b=7,d>>>7}function w(e){let n,t=e;for(;null!==(n=p());){if(\"number\"==typeof(t=t[n]))return t;if(\"object\"!=typeof t)throw new Error(\"invalid huffman sequence\")}return null}function k(e){let n=e,t=0;for(;n>0;){const e=p();if(null===e)return;t=t<<1|e,--n}return t}function x(e){const n=k(e);return n>=1<<e-1?n:n+(-1<<e)+1}let y=0;let P,v=0;function T(e,n,t,r,s){const o=t%f,a=(t/f|0)*e.v+r,c=o*e.h+s;n(e,e.blocks[a][c])}function C(e,n,t){const r=t/e.blocksPerLine|0,s=t%e.blocksPerLine;n(e,e.blocks[r][s])}const g=s.length;let A,L,E,q,D,I;I=u?0===a?0===i?function(e,n){const t=w(e.huffmanTableDC),r=0===t?0:x(t)<<l;e.pred+=r,n[0]=e.pred}:function(e,n){n[0]|=p()<<l}:0===i?function(e,n){if(y>0)return void y--;let r=a;const s=c;for(;r<=s;){const s=w(e.huffmanTableAC),o=15&s,a=s>>4;if(0===o){if(a<15){y=k(a)+(1<<a)-1;break}r+=16}else n[t[r+=a]]=x(o)*(1<<l),r++}}:function(e,n){let r=a;const s=c;let o=0;for(;r<=s;){const s=t[r],a=n[s]<0?-1:1;switch(v){case 0:{const n=w(e.huffmanTableAC),t=15&n;if(o=n>>4,0===t)o<15?(y=k(o)+(1<<o),v=4):(o=16,v=1);else{if(1!==t)throw new Error(\"invalid ACn encoding\");P=x(t),v=o?2:3}continue}case 1:case 2:n[s]?n[s]+=(p()<<l)*a:0==--o&&(v=2===v?3:0);break;case 3:n[s]?n[s]+=(p()<<l)*a:(n[s]=P<<l,v=0);break;case 4:n[s]&&(n[s]+=(p()<<l)*a)}r++}4===v&&0==--y&&(v=0)}:function(e,n){const r=w(e.huffmanTableDC),s=0===r?0:x(r);e.pred+=s,n[0]=e.pred;let o=1;for(;o<64;){const r=w(e.huffmanTableAC),s=15&r,a=r>>4;if(0===s){if(a<15)break;o+=16}else n[t[o+=a]]=x(s),o++}};let z,M,O=0;M=1===g?s[0].blocksPerLine*s[0].blocksPerColumn:f*r.mcusPerColumn;const U=o||M;for(;O<M;){for(L=0;L<g;L++)s[L].pred=0;if(y=0,1===g)for(A=s[0],D=0;D<U;D++)C(A,I,O),O++;else for(D=0;D<U;D++){for(L=0;L<g;L++){A=s[L];const{h:e,v:n}=A;for(E=0;E<n;E++)for(q=0;q<e;q++)T(A,I,O,E,q)}if(++O===M)break}if(b=0,(z=e[m]<<8|e[m+1])<65280)throw new Error(\"marker was not found\");if(!(z>=65488&&z<=65495))break;m+=2}return m-h}function m(e,n){const t=[],{blocksPerLine:u,blocksPerColumn:h}=n,m=u<<3,d=new Int32Array(64),b=new Uint8Array(64);function p(e,t,u){const h=n.quantizationTable;let m,d,b,p,w,k,x,y,P;const v=u;let T;for(T=0;T<64;T++)v[T]=e[T]*h[T];for(T=0;T<8;++T){const e=8*T;0!==v[1+e]||0!==v[2+e]||0!==v[3+e]||0!==v[4+e]||0!==v[5+e]||0!==v[6+e]||0!==v[7+e]?(m=l*v[0+e]+128>>8,d=l*v[4+e]+128>>8,b=v[2+e],p=v[6+e],w=f*(v[1+e]-v[7+e])+128>>8,y=f*(v[1+e]+v[7+e])+128>>8,k=v[3+e]<<4,x=v[5+e]<<4,P=m-d+1>>1,m=m+d+1>>1,d=P,P=b*i+p*c+128>>8,b=b*c-p*i+128>>8,p=P,P=w-x+1>>1,w=w+x+1>>1,x=P,P=y+k+1>>1,k=y-k+1>>1,y=P,P=m-p+1>>1,m=m+p+1>>1,p=P,P=d-b+1>>1,d=d+b+1>>1,b=P,P=w*a+y*o+2048>>12,w=w*o-y*a+2048>>12,y=P,P=k*s+x*r+2048>>12,k=k*r-x*s+2048>>12,x=P,v[0+e]=m+y,v[7+e]=m-y,v[1+e]=d+x,v[6+e]=d-x,v[2+e]=b+k,v[5+e]=b-k,v[3+e]=p+w,v[4+e]=p-w):(P=l*v[0+e]+512>>10,v[0+e]=P,v[1+e]=P,v[2+e]=P,v[3+e]=P,v[4+e]=P,v[5+e]=P,v[6+e]=P,v[7+e]=P)}for(T=0;T<8;++T){const e=T;0!==v[8+e]||0!==v[16+e]||0!==v[24+e]||0!==v[32+e]||0!==v[40+e]||0!==v[48+e]||0!==v[56+e]?(m=l*v[0+e]+2048>>12,d=l*v[32+e]+2048>>12,b=v[16+e],p=v[48+e],w=f*(v[8+e]-v[56+e])+2048>>12,y=f*(v[8+e]+v[56+e])+2048>>12,k=v[24+e],x=v[40+e],P=m-d+1>>1,m=m+d+1>>1,d=P,P=b*i+p*c+2048>>12,b=b*c-p*i+2048>>12,p=P,P=w-x+1>>1,w=w+x+1>>1,x=P,P=y+k+1>>1,k=y-k+1>>1,y=P,P=m-p+1>>1,m=m+p+1>>1,p=P,P=d-b+1>>1,d=d+b+1>>1,b=P,P=w*a+y*o+2048>>12,w=w*o-y*a+2048>>12,y=P,P=k*s+x*r+2048>>12,k=k*r-x*s+2048>>12,x=P,v[0+e]=m+y,v[56+e]=m-y,v[8+e]=d+x,v[48+e]=d-x,v[16+e]=b+k,v[40+e]=b-k,v[24+e]=p+w,v[32+e]=p-w):(P=l*u[T+0]+8192>>14,v[0+e]=P,v[8+e]=P,v[16+e]=P,v[24+e]=P,v[32+e]=P,v[40+e]=P,v[48+e]=P,v[56+e]=P)}for(T=0;T<64;++T){const e=128+(v[T]+8>>4);t[T]=e<0?0:e>255?255:e}}for(let r=0;r<h;r++){const e=r<<3;for(let n=0;n<8;n++)t.push(new Uint8Array(m));for(let s=0;s<u;s++){p(n.blocks[r][s],b,d);let o=0;const a=s<<3;for(let n=0;n<8;n++){const r=t[e+n];for(let e=0;e<8;e++)r[a+e]=b[o++]}}}return t}class d{constructor(){this.jfif=null,this.adobe=null,this.quantizationTables=[],this.huffmanTablesAC=[],this.huffmanTablesDC=[],this.resetFrames()}resetFrames(){this.frames=[]}parse(e){let n=0;function r(){const t=e[n]<<8|e[n+1];return n+=2,t}function s(){const t=r(),s=e.subarray(n,n+t-2);return n+=s.length,s}function o(e){let n,t,r=0,s=0;for(t in e.components)e.components.hasOwnProperty(t)&&(r<(n=e.components[t]).h&&(r=n.h),s<n.v&&(s=n.v));const o=Math.ceil(e.samplesPerLine/8/r),a=Math.ceil(e.scanLines/8/s);for(t in e.components)if(e.components.hasOwnProperty(t)){n=e.components[t];const c=Math.ceil(Math.ceil(e.samplesPerLine/8)*n.h/r),i=Math.ceil(Math.ceil(e.scanLines/8)*n.v/s),l=o*n.h,f=a*n.v,u=[];for(let e=0;e<f;e++){const e=[];for(let n=0;n<l;n++)e.push(new Int32Array(64));u.push(e)}n.blocksPerLine=c,n.blocksPerColumn=i,n.blocks=u}e.maxH=r,e.maxV=s,e.mcusPerLine=o,e.mcusPerColumn=a}let a=r();if(65496!==a)throw new Error(\"SOI not found\");for(a=r();65497!==a;){switch(a){case 65280:break;case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:{const e=s();65504===a&&74===e[0]&&70===e[1]&&73===e[2]&&70===e[3]&&0===e[4]&&(this.jfif={version:{major:e[5],minor:e[6]},densityUnits:e[7],xDensity:e[8]<<8|e[9],yDensity:e[10]<<8|e[11],thumbWidth:e[12],thumbHeight:e[13],thumbData:e.subarray(14,14+3*e[12]*e[13])}),65518===a&&65===e[0]&&100===e[1]&&111===e[2]&&98===e[3]&&101===e[4]&&0===e[5]&&(this.adobe={version:e[6],flags0:e[7]<<8|e[8],flags1:e[9]<<8|e[10],transformCode:e[11]});break}case 65499:{const s=r()+n-2;for(;n<s;){const s=e[n++],o=new Int32Array(64);if(s>>4==0)for(let r=0;r<64;r++){o[t[r]]=e[n++]}else{if(s>>4!=1)throw new Error(\"DQT: invalid table spec\");for(let e=0;e<64;e++){o[t[e]]=r()}}this.quantizationTables[15&s]=o}break}case 65472:case 65473:case 65474:{r();const t={extended:65473===a,progressive:65474===a,precision:e[n++],scanLines:r(),samplesPerLine:r(),components:{},componentsOrder:[]},s=e[n++];let c;for(let r=0;r<s;r++){c=e[n];const r=e[n+1]>>4,s=15&e[n+1],o=e[n+2];t.componentsOrder.push(c),t.components[c]={h:r,v:s,quantizationIdx:o},n+=3}o(t),this.frames.push(t);break}case 65476:{const t=r();for(let r=2;r<t;){const t=e[n++],s=new Uint8Array(16);let o=0;for(let r=0;r<16;r++,n++)s[r]=e[n],o+=s[r];const a=new Uint8Array(o);for(let r=0;r<o;r++,n++)a[r]=e[n];r+=17+o,t>>4==0?this.huffmanTablesDC[15&t]=u(s,a):this.huffmanTablesAC[15&t]=u(s,a)}break}case 65501:r(),this.resetInterval=r();break;case 65498:{r();const t=e[n++],s=[],o=this.frames[0];for(let r=0;r<t;r++){const t=o.components[e[n++]],r=e[n++];t.huffmanTableDC=this.huffmanTablesDC[r>>4],t.huffmanTableAC=this.huffmanTablesAC[15&r],s.push(t)}const a=e[n++],c=e[n++],i=e[n++],l=h(e,n,o,s,this.resetInterval,a,c,i>>4,15&i);n+=l;break}case 65535:255!==e[n]&&n--;break;default:if(255===e[n-3]&&e[n-2]>=192&&e[n-2]<=254){n-=3;break}throw new Error(`unknown JPEG marker ${a.toString(16)}`)}a=r()}}getResult(){const{frames:e}=this;if(0===this.frames.length)throw new Error(\"no frames were decoded\");this.frames.length>1&&console.warn(\"more than one frame is not supported\");for(let l=0;l<this.frames.length;l++){const e=this.frames[l].components;for(const n of Object.keys(e))e[n].quantizationTable=this.quantizationTables[e[n].quantizationIdx],delete e[n].quantizationIdx}const n=e[0],{components:t,componentsOrder:r}=n,s=[],o=n.samplesPerLine,a=n.scanLines;for(let l=0;l<r.length;l++){const e=t[r[l]];s.push({lines:m(n,e),scaleX:e.h/n.maxH,scaleY:e.v/n.maxV})}const c=new Uint8Array(o*a*s.length);let i=0;for(let l=0;l<a;++l)for(let e=0;e<o;++e)for(let n=0;n<s.length;++n){const t=s[n];c[i]=t.lines[0|l*t.scaleY][0|e*t.scaleX],++i}return c}}class b extends e.default{constructor(e){super(),this.reader=new d,e.JPEGTables&&this.reader.parse(e.JPEGTables)}decodeBlock(e){return this.reader.resetFrames(),this.reader.parse(new Uint8Array(e)),this.reader.getResult().buffer}}exports.default=b;\n},{\"./basedecoder\":\"FJDe\"}],\"JAiC\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.default=void 0;var e=require(\"pako/lib/inflate\"),r=t(require(\"./basedecoder\"));function t(e){return e&&e.__esModule?e:{default:e}}class u extends r.default{decodeBlock(r){return(0,e.inflate)(new Uint8Array(r)).buffer}}exports.default=u;\n},{\"./basedecoder\":\"FJDe\"}],\"OcPz\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.default=void 0;var e=t(require(\"./basedecoder\"));function t(e){return e&&e.__esModule?e:{default:e}}class r extends e.default{decodeBlock(e){const t=new DataView(e),r=[];for(let o=0;o<e.byteLength;++o){let e=t.getInt8(o);if(e<0){const s=t.getUint8(o+1);e=-e;for(let t=0;t<=e;++t)r.push(s);o+=1}else{for(let s=0;s<=e;++s)r.push(t.getUint8(o+s+1));o+=e+1}}return new Uint8Array(r).buffer}}exports.default=r;\n},{\"./basedecoder\":\"FJDe\"}],\"FGCZ\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.getDecoder=u;var e=o(require(\"./raw\")),r=o(require(\"./lzw\")),t=o(require(\"./jpeg\")),n=o(require(\"./deflate\")),s=o(require(\"./packbits\"));function o(e){return e&&e.__esModule?e:{default:e}}function u(o){switch(o.Compression){case void 0:case 1:return new e.default;case 5:return new r.default;case 6:throw new Error(\"old style JPEG compression is not supported.\");case 7:return new t.default(o);case 8:case 32946:return new n.default;case 32773:return new s.default;default:throw new Error(`Unknown compression method identifier: ${o.Compression}`)}}\n},{\"./raw\":\"V9bQ\",\"./lzw\":\"tcId\",\"./jpeg\":\"J7kk\",\"./deflate\":\"JAiC\",\"./packbits\":\"OcPz\"}],\"OQju\":[function(require,module,exports) {\n\"use strict\";function e(e,t,r,n=1){return new(Object.getPrototypeOf(e).constructor)(t*r*n)}function t(t,r,n,o,a){const s=r/o,c=n/a;return t.map(t=>{const l=e(t,o,a);for(let e=0;e<a;++e){const a=Math.min(Math.round(c*e),n-1);for(let n=0;n<o;++n){const c=Math.min(Math.round(s*n),r-1),i=t[a*r+c];l[e*o+n]=i}}return l})}function r(e,t,r){return(1-r)*e+r*t}function n(t,n,o,a,s){const c=n/a,l=o/s;return t.map(t=>{const i=e(t,a,s);for(let e=0;e<s;++e){const s=l*e,u=Math.floor(s),f=Math.min(Math.ceil(s),o-1);for(let o=0;o<a;++o){const l=c*o,h=l%1,p=Math.floor(l),M=Math.min(Math.ceil(l),n-1),m=t[u*n+p],d=t[u*n+M],w=t[f*n+p],x=t[f*n+M],b=r(r(m,d,h),r(w,x,h),s%1);i[e*a+o]=b}}return i})}function o(e,r,o,a,s,c=\"nearest\"){switch(c.toLowerCase()){case\"nearest\":return t(e,r,o,a,s);case\"bilinear\":case\"linear\":return n(e,r,o,a,s);default:throw new Error(`Unsupported resampling method: '${c}'`)}}function a(t,r,n,o,a,s){const c=r/o,l=n/a,i=e(t,o,a,s);for(let e=0;e<a;++e){const a=Math.min(Math.round(l*e),n-1);for(let n=0;n<o;++n){const l=Math.min(Math.round(c*n),r-1);for(let c=0;c<s;++c){const u=t[a*r*s+l*s+c];i[e*o*s+n*s+c]=u}}}return i}function s(t,n,o,a,s,c){const l=n/a,i=o/s,u=e(t,a,s,c);for(let e=0;e<s;++e){const s=i*e,f=Math.floor(s),h=Math.min(Math.ceil(s),o-1);for(let o=0;o<a;++o){const i=l*o,p=i%1,M=Math.floor(i),m=Math.min(Math.ceil(i),n-1);for(let l=0;l<c;++l){const i=t[f*n*c+M*c+l],d=t[f*n*c+m*c+l],w=t[h*n*c+M*c+l],x=t[h*n*c+m*c+l],b=r(r(i,d,p),r(w,x,p),s%1);u[e*a*c+o*c+l]=b}}}return u}function c(e,t,r,n,o,c,l=\"nearest\"){switch(l.toLowerCase()){case\"nearest\":return a(e,t,r,n,o,c);case\"bilinear\":case\"linear\":return s(e,t,r,n,o,c);default:throw new Error(`Unsupported resampling method: '${l}'`)}}Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.resampleNearest=t,exports.resampleBilinear=n,exports.resample=o,exports.resampleNearestInterleaved=a,exports.resampleBilinearInterleaved=s,exports.resampleInterleaved=c;\n},{}],\"eOWo\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.default=void 0;var t=a(require(\"txml\")),e=require(\"./globals\"),r=require(\"./rgb\"),i=require(\"./compression\"),o=require(\"./resample\");function a(t){return t&&t.__esModule?t:{default:t}}function s(t,e,r){let i=0;for(let o=e;o<r;++o)i+=t[o];return i}function n(t,e,r){switch(t){case 1:switch(e){case 8:return new Uint8Array(r);case 16:return new Uint16Array(r);case 32:return new Uint32Array(r)}break;case 2:switch(e){case 8:return new Int8Array(r);case 16:return new Int16Array(r);case 32:return new Int32Array(r)}break;case 3:switch(e){case 32:return new Float32Array(r);case 64:return new Float64Array(r)}}throw Error(\"Unsupported data format/bitsPerSample\")}class l{constructor(t,e,r,i,o,a){this.fileDirectory=t,this.geoKeys=e,this.dataView=r,this.littleEndian=i,this.tiles=o?{}:null,this.isTiled=!t.StripOffsets;const s=t.PlanarConfiguration;if(this.planarConfiguration=void 0===s?1:s,1!==this.planarConfiguration&&2!==this.planarConfiguration)throw new Error(\"Invalid planar configuration.\");this.source=a}getFileDirectory(){return this.fileDirectory}getGeoKeys(){return this.geoKeys}getWidth(){return this.fileDirectory.ImageWidth}getHeight(){return this.fileDirectory.ImageLength}getSamplesPerPixel(){return this.fileDirectory.SamplesPerPixel}getTileWidth(){return this.isTiled?this.fileDirectory.TileWidth:this.getWidth()}getTileHeight(){return this.isTiled?this.fileDirectory.TileLength:void 0!==this.fileDirectory.RowsPerStrip?Math.min(this.fileDirectory.RowsPerStrip,this.getHeight()):this.getHeight()}getBytesPerPixel(){let t=0;for(let e=0;e<this.fileDirectory.BitsPerSample.length;++e){const r=this.fileDirectory.BitsPerSample[e];if(r%8!=0)throw new Error(`Sample bit-width of ${r} is not supported.`);if(r!==this.fileDirectory.BitsPerSample[0])throw new Error(\"Differing size of samples in a pixel are not supported.\");t+=r}return t/8}getSampleByteSize(t){if(t>=this.fileDirectory.BitsPerSample.length)throw new RangeError(`Sample index ${t} is out of range.`);const e=this.fileDirectory.BitsPerSample[t];if(e%8!=0)throw new Error(`Sample bit-width of ${e} is not supported.`);return e/8}getReaderForSample(t){const e=this.fileDirectory.SampleFormat?this.fileDirectory.SampleFormat[t]:1,r=this.fileDirectory.BitsPerSample[t];switch(e){case 1:switch(r){case 8:return DataView.prototype.getUint8;case 16:return DataView.prototype.getUint16;case 32:return DataView.prototype.getUint32}break;case 2:switch(r){case 8:return DataView.prototype.getInt8;case 16:return DataView.prototype.getInt16;case 32:return DataView.prototype.getInt32}break;case 3:switch(r){case 32:return DataView.prototype.getFloat32;case 64:return DataView.prototype.getFloat64}}throw Error(\"Unsupported data format/bitsPerSample\")}getArrayForSample(t,e){return n(this.fileDirectory.SampleFormat?this.fileDirectory.SampleFormat[t]:1,this.fileDirectory.BitsPerSample[t],e)}async getTileOrStrip(t,e,r,i){const o=Math.ceil(this.getWidth()/this.getTileWidth()),a=Math.ceil(this.getHeight()/this.getTileHeight());let s;const{tiles:n}=this;let l,h;1===this.planarConfiguration?s=e*o+t:2===this.planarConfiguration&&(s=r*o*a+e*o+t),this.isTiled?(l=this.fileDirectory.TileOffsets[s],h=this.fileDirectory.TileByteCounts[s]):(l=this.fileDirectory.StripOffsets[s],h=this.fileDirectory.StripByteCounts[s]);const c=await this.source.fetch(l,h);let p;return null===n?p=i.decode(this.fileDirectory,c):n[s]||(p=i.decode(this.fileDirectory,c),n[s]=p),{x:t,y:e,sample:r,data:await p}}async _readRaster(t,e,r,i,a,n,l,h){const c=this.getTileWidth(),p=this.getTileHeight(),f=Math.max(Math.floor(t[0]/c),0),g=Math.min(Math.ceil(t[2]/c),Math.ceil(this.getWidth()/this.getTileWidth())),u=Math.max(Math.floor(t[1]/p),0),m=Math.min(Math.ceil(t[3]/p),Math.ceil(this.getHeight()/this.getTileHeight())),d=t[2]-t[0];let y=this.getBytesPerPixel();const w=[],D=[];for(let o=0;o<e.length;++o)1===this.planarConfiguration?w.push(s(this.fileDirectory.BitsPerSample,0,e[o])/8):w.push(0),D.push(this.getReaderForSample(e[o]));const M=[],{littleEndian:S}=this;for(let o=u;o<m;++o)for(let s=f;s<g;++s)for(let n=0;n<e.length;++n){const l=n,h=e[n];2===this.planarConfiguration&&(y=this.getSampleByteSize(h));const f=this.getTileOrStrip(s,o,h,a);M.push(f),f.then(o=>{const a=o.data,s=new DataView(a),n=o.y*p,h=o.x*c,f=(o.y+1)*p,g=(o.x+1)*c,u=D[l],m=Math.min(p,p-(f-t[3])),M=Math.min(c,c-(g-t[2]));for(let p=Math.max(0,t[1]-n);p<m;++p)for(let o=Math.max(0,t[0]-h);o<M;++o){const a=(p*c+o)*y,f=u.call(s,a+w[l],S);let g;i?(g=(p+n-t[1])*d*e.length+(o+h-t[0])*e.length+l,r[g]=f):(g=(p+n-t[1])*d+o+h-t[0],r[l][g]=f)}})}if(await Promise.all(M),n&&t[2]-t[0]!==n||l&&t[3]-t[1]!==l){let a;return(a=i?(0,o.resampleInterleaved)(r,t[2]-t[0],t[3]-t[1],n,l,e.length,h):(0,o.resample)(r,t[2]-t[0],t[3]-t[1],n,l,h)).width=n,a.height=l,a}return r.width=n||t[2]-t[0],r.height=l||t[3]-t[1],r}async readRasters({window:t,samples:e=[],interleave:r,pool:o=null,width:a,height:s,resampleMethod:l,fillValue:h}={}){const c=t||[0,0,this.getWidth(),this.getHeight()];if(c[0]>c[2]||c[1]>c[3])throw new Error(\"Invalid subsets\");const p=(c[2]-c[0])*(c[3]-c[1]);if(e&&e.length){for(let i=0;i<e.length;++i)if(e[i]>=this.fileDirectory.SamplesPerPixel)return Promise.reject(new RangeError(`Invalid sample index '${e[i]}'.`))}else for(let i=0;i<this.fileDirectory.SamplesPerPixel;++i)e.push(i);let f;if(r){f=n(this.fileDirectory.SampleFormat?Math.max.apply(null,this.fileDirectory.SampleFormat):1,Math.max.apply(null,this.fileDirectory.BitsPerSample),p*e.length),h&&f.fill(h)}else{f=[];for(let t=0;t<e.length;++t){const r=this.getArrayForSample(e[t],p);Array.isArray(h)&&t<h.length?r.fill(h[t]):h&&!Array.isArray(h)&&r.fill(h),f.push(r)}}const g=o||(0,i.getDecoder)(this.fileDirectory);return await this._readRaster(c,e,f,r,g,a,s,l)}async readRGB({window:t,pool:i=null,width:o,height:a,resampleMethod:s,enableAlpha:n=!1}={}){const l=t||[0,0,this.getWidth(),this.getHeight()];if(l[0]>l[2]||l[1]>l[3])throw new Error(\"Invalid subsets\");const h=this.fileDirectory.PhotometricInterpretation;if(h===e.photometricInterpretations.RGB){let r=[0,1,2];if(this.fileDirectory.ExtraSamples!==e.ExtraSamplesValues.Unspecified&&n){r=[];for(let t=0;t<this.fileDirectory.BitsPerSample.length;t+=1)r.push(t)}return this.readRasters({window:t,interleave:!0,samples:r,pool:i,width:o,height:a})}let c;switch(h){case e.photometricInterpretations.WhiteIsZero:case e.photometricInterpretations.BlackIsZero:case e.photometricInterpretations.Palette:c=[0];break;case e.photometricInterpretations.CMYK:c=[0,1,2,3];break;case e.photometricInterpretations.YCbCr:case e.photometricInterpretations.CIELab:c=[0,1,2];break;default:throw new Error(\"Invalid or unsupported photometric interpretation.\")}const p={window:l,interleave:!0,samples:c,pool:i,width:o,height:a,resampleMethod:s},{fileDirectory:f}=this,g=await this.readRasters(p),u=2**this.fileDirectory.BitsPerSample[0];let m;switch(h){case e.photometricInterpretations.WhiteIsZero:m=(0,r.fromWhiteIsZero)(g,u);break;case e.photometricInterpretations.BlackIsZero:m=(0,r.fromBlackIsZero)(g,u);break;case e.photometricInterpretations.Palette:m=(0,r.fromPalette)(g,f.ColorMap);break;case e.photometricInterpretations.CMYK:m=(0,r.fromCMYK)(g);break;case e.photometricInterpretations.YCbCr:m=(0,r.fromYCbCr)(g);break;case e.photometricInterpretations.CIELab:m=(0,r.fromCIELab)(g);break;default:throw new Error(\"Unsupported photometric interpretation.\")}return m.width=g.width,m.height=g.height,m}getTiePoints(){if(!this.fileDirectory.ModelTiepoint)return[];const t=[];for(let e=0;e<this.fileDirectory.ModelTiepoint.length;e+=6)t.push({i:this.fileDirectory.ModelTiepoint[e],j:this.fileDirectory.ModelTiepoint[e+1],k:this.fileDirectory.ModelTiepoint[e+2],x:this.fileDirectory.ModelTiepoint[e+3],y:this.fileDirectory.ModelTiepoint[e+4],z:this.fileDirectory.ModelTiepoint[e+5]});return t}getGDALMetadata(e=null){const r={};if(!this.fileDirectory.GDAL_METADATA)return null;const i=this.fileDirectory.GDAL_METADATA,o=(0,t.default)(i.substring(0,i.length-1));if(!o[0].tagName)throw new Error(\"Failed to parse GDAL metadata XML.\");const a=o[0];if(\"GDALMetadata\"!==a.tagName)throw new Error(\"Unexpected GDAL metadata XML tag.\");let s=a.children.filter(t=>\"Item\"===t.tagName);e&&(s=s.filter(t=>Number(t.attributes.sample)===e));for(let t=0;t<s.length;++t){const e=s[t];r[e.attributes.name]=e.children[0]}return r}getGDALNoData(){if(!this.fileDirectory.GDAL_NODATA)return null;const t=this.fileDirectory.GDAL_NODATA;return Number(t.substring(0,t.length-1))}getOrigin(){const t=this.fileDirectory.ModelTiepoint,e=this.fileDirectory.ModelTransformation;if(t&&6===t.length)return[t[3],t[4],t[5]];if(e)return[e[3],e[7],e[11]];throw new Error(\"The image does not have an affine transformation.\")}getResolution(t=null){const e=this.fileDirectory.ModelPixelScale,r=this.fileDirectory.ModelTransformation;if(e)return[e[0],-e[1],e[2]];if(r)return[r[0],r[5],r[10]];if(t){const[e,r,i]=t.getResolution();return[e*t.getWidth()/this.getWidth(),r*t.getHeight()/this.getHeight(),i*t.getWidth()/this.getWidth()]}throw new Error(\"The image does not have an affine transformation.\")}pixelIsArea(){return 1===this.geoKeys.GTRasterTypeGeoKey}getBoundingBox(){const t=this.getOrigin(),e=this.getResolution(),r=t[0],i=t[1],o=r+e[0]*this.getWidth(),a=i+e[1]*this.getHeight();return[Math.min(r,o),Math.min(i,a),Math.max(r,o),Math.max(i,a)]}}var h=l;exports.default=h;\n},{\"./globals\":\"j27V\",\"./rgb\":\"fpBl\",\"./compression\":\"FGCZ\",\"./resample\":\"OQju\"}],\"dqpX\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.default=void 0;class t{constructor(t){this._dataView=new DataView(t)}get buffer(){return this._dataView.buffer}getUint64(t,e){const i=this.getUint32(t,e),n=this.getUint32(t+4,e);return e?i<<32|n:n<<32|i}getInt64(t,e){let i,n;return e?(i=this.getInt32(t,e))<<32|(n=this.getUint32(t+4,e)):(i=this.getUint32(t,e),(n=this.getInt32(t+4,e))<<32|i)}getUint8(t,e){return this._dataView.getUint8(t,e)}getInt8(t,e){return this._dataView.getInt8(t,e)}getUint16(t,e){return this._dataView.getUint16(t,e)}getInt16(t,e){return this._dataView.getInt16(t,e)}getUint32(t,e){return this._dataView.getUint32(t,e)}getInt32(t,e){return this._dataView.getInt32(t,e)}getFloat32(t,e){return this._dataView.getFloat32(t,e)}getFloat64(t,e){return this._dataView.getFloat64(t,e)}}exports.default=t;\n},{}],\"dGLV\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.default=void 0;class t{constructor(t,e,i,s){this._dataView=new DataView(t),this._sliceOffset=e,this._littleEndian=i,this._bigTiff=s}get sliceOffset(){return this._sliceOffset}get sliceTop(){return this._sliceOffset+this.buffer.byteLength}get littleEndian(){return this._littleEndian}get bigTiff(){return this._bigTiff}get buffer(){return this._dataView.buffer}covers(t,e){return this.sliceOffset<=t&&this.sliceTop>=t+e}readUint8(t){return this._dataView.getUint8(t-this._sliceOffset,this._littleEndian)}readInt8(t){return this._dataView.getInt8(t-this._sliceOffset,this._littleEndian)}readUint16(t){return this._dataView.getUint16(t-this._sliceOffset,this._littleEndian)}readInt16(t){return this._dataView.getInt16(t-this._sliceOffset,this._littleEndian)}readUint32(t){return this._dataView.getUint32(t-this._sliceOffset,this._littleEndian)}readInt32(t){return this._dataView.getInt32(t-this._sliceOffset,this._littleEndian)}readFloat32(t){return this._dataView.getFloat32(t-this._sliceOffset,this._littleEndian)}readFloat64(t){return this._dataView.getFloat64(t-this._sliceOffset,this._littleEndian)}readUint64(t){const e=this.readUint32(t),i=this.readUint32(t+4);let s;if(this._littleEndian){if(s=e+2**32*i,!Number.isSafeInteger(s))throw new Error(`${s} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return s}if(s=2**32*e+i,!Number.isSafeInteger(s))throw new Error(`${s} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return s}readInt64(t){let e,i;if(this._littleEndian){if(e=this.readInt32(t),i=this.readUint32(t+4),combined=e+2**32*i,!Number.isSafeInteger(combined))throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return combined}if(e=this.readUint32(t-this._sliceOffset),i=this.readInt32(t-this._sliceOffset+4),combined=2**32*e+i,!Number.isSafeInteger(combined))throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return combined}readOffset(t){return this._bigTiff?this.readUint64(t):this.readUint32(t)}}exports.default=t;\n},{}],\"dHPO\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.default=void 0,require(\"threads/register\");var e=require(\"threads\");const r=\"undefined\"!=typeof navigator?navigator.hardwareConcurrency:null;class t{constructor(t=r){const o=new Worker(\"/decoder.worker.7cb947d7.js\");this.pool=(0,e.Pool)(()=>(0,e.spawn)(o),t)}async decode(e,r){return new Promise((t,o)=>{this.pool.queue(async s=>{try{const n=await s(e,r);t(n)}catch(a){o(a)}})})}destroy(){this.pool.terminate(!0)}}var o=t;exports.default=o;\n},{\"./decoder.worker.js\":[[\"decoder.worker.7cb947d7.js\",\"LHx9\"],\"decoder.worker.7cb947d7.js.map\",\"LHx9\"]}],\"cUx7\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.makeFetchSource=f,exports.makeXHRSource=l,exports.makeHttpSource=h,exports.makeRemoteSource=b,exports.makeBufferSource=d,exports.makeFileSource=p,exports.makeFileReaderSource=y;var e=require(\"buffer\"),t=require(\"fs\"),s=n(require(\"http\")),r=n(require(\"https\")),o=n(require(\"url\"));function n(e){return e&&e.__esModule?e:{default:e}}function a(e,t,s){const r=t+s,o=new ArrayBuffer(s),n=new Uint8Array(o);for(const a of e){const e=a.offset-t,s=a.top-r;let o,i=0,c=0;e<0?i=-e:e>0&&(c=e),s<0?o=a.length-i:s>0&&(o=r-a.offset-i);const u=new Uint8Array(a.data,i,o);n.set(u,c)}return o}function i(e){if(0===e.length)return[];const t=[];let s=[];t.push(s);for(let r=0;r<e.length;++r)0===r||e[r]===e[r-1]+1?s.push(e[r]):(s=[e[r]],t.push(s));return t}async function c(e){return new Promise(t=>setTimeout(t,e))}class u{constructor(e,{blockSize:t=65536}={}){this.retrievalFunction=e,this.blockSize=t,this.blockRequests=new Map,this.blocks=new Map,this.blockIdsAwaitingRequest=null}async fetch(e,t,s=!1){const r=e+t,o=[],n=[],u=[];for(let a=Math.floor(e/this.blockSize)*this.blockSize;a<r;a+=this.blockSize){const e=Math.floor(a/this.blockSize);this.blocks.has(e)||this.blockRequests.has(e)||n.push(e),this.blockRequests.has(e)&&u.push(this.blockRequests.get(e)),o.push(e)}if(this.blockIdsAwaitingRequest)for(let a=0;a<n.length;++a){const e=n[a];this.blockIdsAwaitingRequest.add(e)}else this.blockIdsAwaitingRequest=new Set(n);if(s||await c(),this.blockIdsAwaitingRequest){const e=i(Array.from(this.blockIdsAwaitingRequest).sort());for(const t of e){const e=this.requestData(t[0]*this.blockSize,t.length*this.blockSize);for(let s=0;s<t.length;++s){const r=t[s];this.blockRequests.set(r,(async()=>{const t=await e,o=s*this.blockSize,n=Math.min(o+this.blockSize,t.data.byteLength),a=t.data.slice(o,n);this.blockRequests.delete(r),this.blocks.set(r,{data:a,offset:t.offset+o,length:a.byteLength,top:t.offset+n})})())}}this.blockIdsAwaitingRequest=null}const f=[];for(const a of n)this.blockRequests.has(a)&&f.push(this.blockRequests.get(a));return await Promise.all(f),await Promise.all(u),a(o.map(e=>this.blocks.get(e)),e,t)}async requestData(e,t){const s=await this.retrievalFunction(e,t);return s.length?s.length!==s.data.byteLength&&(s.data=s.data.slice(0,s.length)):s.length=s.data.byteLength,s.top=s.offset+s.length,s}}function f(e,{headers:t={},blockSize:s}={}){return new u(async(s,r)=>{const o=await fetch(e,{headers:{...t,Range:`bytes=${s}-${s+r-1}`}});if(o.ok){if(206===o.status){return{data:o.arrayBuffer?await o.arrayBuffer():(await o.buffer()).buffer,offset:s,length:r}}{const e=o.arrayBuffer?await o.arrayBuffer():(await o.buffer()).buffer;return{data:e,offset:0,length:e.byteLength}}}throw new Error(\"Error fetching data.\")},{blockSize:s})}function l(e,{headers:t={},blockSize:s}={}){return new u(async(s,r)=>new Promise((o,n)=>{const a=new XMLHttpRequest;a.open(\"GET\",e),a.responseType=\"arraybuffer\";const i={...t,Range:`bytes=${s}-${s+r-1}`};for(const[e,t]of Object.entries(i))a.setRequestHeader(e,t);a.onload=(()=>{const e=a.response;206===a.status?o({data:e,offset:s,length:r}):o({data:e,offset:0,length:e.byteLength})}),a.onerror=n,a.send()}),{blockSize:s})}function h(t,{headers:n={},blockSize:a}={}){return new u(async(a,i)=>new Promise((c,u)=>{const f=o.default.parse(t);(\"http:\"===f.protocol?s.default:r.default).get({...f,headers:{...n,Range:`bytes=${a}-${a+i-1}`}},t=>{const s=[];t.on(\"data\",e=>{s.push(e)}),t.on(\"end\",()=>{const t=e.Buffer.concat(s).buffer;c({data:t,offset:a,length:t.byteLength})})}).on(\"error\",u)}),{blockSize:a})}function b(e,t){const{forceXHR:r}=t;if(\"function\"==typeof fetch&&!r)return f(e,t);if(\"undefined\"!=typeof XMLHttpRequest)return l(e,t);if(s.default.get)return h(e,t);throw new Error(\"No remote source available\")}function d(e){return{fetch:async(t,s)=>e.slice(t,t+s)}}function k(e){return new Promise((s,r)=>{(0,t.close)(e,e=>{e?r(e):s()})})}function w(e,s,r){return new Promise((o,n)=>{(0,t.open)(e,s,r,(e,t)=>{e?n(e):o(t)})})}function g(...e){return new Promise((s,r)=>{(0,t.read)(...e,(e,t,o)=>{e?r(e):s({bytesRead:t,buffer:o})})})}function p(t){const s=w(t,\"r\");return{async fetch(t,r){const o=await s,{buffer:n}=await g(o,e.Buffer.alloc(r),0,r,t);return n.buffer},async close(){const e=await s;return await k(e)}}}function y(e){return{fetch:async(t,s)=>new Promise((r,o)=>{const n=e.slice(t,t+s),a=new FileReader;a.onload=(e=>r(e.target.result)),a.onerror=o,a.readAsArrayBuffer(n)})}}\n},{}],\"FOZT\":[function(require,module,exports) {\n\"use strict\";function t(t,n){for(const r in n)n.hasOwnProperty(r)&&(t[r]=n[r])}function n(t,n){const r=[],e=t.length;for(let o=0;o<e;o+=n){const e=[];for(let r=o;r<o+n;r++)e.push(t[r]);r.push(e)}return r}function r(t,n){if(t.length<n.length)return!1;return t.substr(t.length-n.length)===n}function e(t,n){const{length:r}=t;for(let e=0;e<r;e++)n(t[e],e)}function o(t){const n={};for(const r in t)if(t.hasOwnProperty(r)){n[t[r]]=r}return n}function s(t){const n=[];for(let r=0;r<t;r++)n.push(r);return n}function u(t,n){const r=[];for(let e=0;e<t;e++)r.push(n(e));return r}function c(t){const n=[],{length:r}=t;for(let e=0;e<r;e++)n.push(t[e]);return n}function f(t){return t.length?c(t).map(f):t}Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.assign=t,exports.chunk=n,exports.endsWith=r,exports.forEach=e,exports.invert=o,exports.range=s,exports.times=u,exports.toArray=c,exports.toArrayRecursively=f;\n},{}],\"BGyE\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.writeGeotiff=p;var e=require(\"./globals\"),t=require(\"./utils\");const r=(0,t.invert)(e.fieldTagNames),o=(0,t.invert)(e.geoKeyNames),i={};(0,t.assign)(i,r),(0,t.assign)(i,o);const n=(0,t.invert)(e.fieldTypeNames),s=1e3,a={nextZero:(e,t)=>{let r=t;for(;0!==e[r];)r++;return r},readUshort:(e,t)=>e[t]<<8|e[t+1],readShort:(e,t)=>{const r=a.ui8;return r[0]=e[t+1],r[1]=e[t+0],a.i16[0]},readInt:(e,t)=>{const r=a.ui8;return r[0]=e[t+3],r[1]=e[t+2],r[2]=e[t+1],r[3]=e[t+0],a.i32[0]},readUint:(e,t)=>{const r=a.ui8;return r[0]=e[t+3],r[1]=e[t+2],r[2]=e[t+1],r[3]=e[t+0],a.ui32[0]},readASCII:(e,t,r)=>r.map(r=>String.fromCharCode(e[t+r])).join(\"\"),readFloat:(e,r)=>{const o=a.ui8;return(0,t.times)(4,t=>{o[t]=e[r+3-t]}),a.fl32[0]},readDouble:(e,r)=>{const o=a.ui8;return(0,t.times)(8,t=>{o[t]=e[r+7-t]}),a.fl64[0]},writeUshort:(e,t,r)=>{e[t]=r>>8&255,e[t+1]=255&r},writeUint:(e,t,r)=>{e[t]=r>>24&255,e[t+1]=r>>16&255,e[t+2]=r>>8&255,e[t+3]=r>>0&255},writeASCII:(e,r,o)=>{(0,t.times)(o.length,t=>{e[r+t]=o.charCodeAt(t)})},ui8:new Uint8Array(8)};a.fl64=new Float64Array(a.ui8.buffer),a.writeDouble=((e,r,o)=>{a.fl64[0]=o,(0,t.times)(8,t=>{e[r+t]=a.ui8[7-t]})});const l=(r,o,i,s)=>{let a=i;const l=Object.keys(s).filter(e=>null!=e&&\"undefined\"!==e);r.writeUshort(o,a,l.length);let f=(a+=2)+12*l.length+4;for(const u of l){let i=null;\"number\"==typeof u?i=u:\"string\"==typeof u&&(i=parseInt(u,10));const l=e.fieldTagTypes[i],c=n[l];if(null==l||void 0===l||void 0===l)throw new Error(`unknown type of tag: ${i}`);let h=s[u];if(void 0===h)throw new Error(`failed to get value for key ${u}`);\"ASCII\"===l&&\"string\"==typeof h&&!1===(0,t.endsWith)(h,\"\\0\")&&(h+=\"\\0\");const m=h.length;r.writeUshort(o,a,i),a+=2,r.writeUshort(o,a,c),a+=2,r.writeUint(o,a,m);let p=[-1,1,1,2,4,8,0,0,0,0,0,0,8][c]*m,y=a+=4;p>4&&(r.writeUint(o,a,f),y=f),\"ASCII\"===l?r.writeASCII(o,y,h):\"SHORT\"===l?(0,t.times)(m,e=>{r.writeUshort(o,y+2*e,h[e])}):\"LONG\"===l?(0,t.times)(m,e=>{r.writeUint(o,y+4*e,h[e])}):\"RATIONAL\"===l?(0,t.times)(m,e=>{r.writeUint(o,y+8*e,Math.round(1e4*h[e])),r.writeUint(o,y+8*e+4,1e4)}):\"DOUBLE\"===l&&(0,t.times)(m,e=>{r.writeDouble(o,y+8*e,h[e])}),p>4&&(f+=p+=1&p),a+=4}return[a,f]},f=e=>{const t=new Uint8Array(1e3);let r=4;const o=a;t[0]=77,t[1]=77,t[3]=42;let i=8;if(o.writeUint(t,r,i),r+=4,e.forEach((r,n)=>{const s=l(o,t,i,r);i=s[1],n<e.length-1&&o.writeUint(t,s[0],i)}),t.slice)return t.slice(0,i).buffer;const n=new Uint8Array(i);for(let s=0;s<i;s++)n[s]=t[s];return n.buffer},u=(e,r,o,i)=>{if(null==o)throw new Error(`you passed into encodeImage a width of type ${o}`);if(null==r)throw new Error(`you passed into encodeImage a width of type ${r}`);const n={256:[r],257:[o],273:[1e3],278:[o],305:\"geotiff.js\"};if(i)for(const t in i)i.hasOwnProperty(t)&&(n[t]=i[t]);const s=new Uint8Array(f([n])),a=new Uint8Array(e),l=n[277],u=new Uint8Array(1e3+r*o*l);return(0,t.times)(s.length,e=>{u[e]=s[e]}),(0,t.forEach)(a,(e,t)=>{u[1e3+t]=e}),u.buffer},c=e=>{const t={};for(const r in e)\"StripOffsets\"!==r&&(i[r]||console.error(r,\"not in name2code:\",Object.keys(i)),t[i[r]]=e[r]);return t},h=e=>Array.isArray(e)?e:[e],m=[[\"Compression\",1],[\"PlanarConfiguration\",1],[\"XPosition\",0],[\"YPosition\",0],[\"ResolutionUnit\",1],[\"ExtraSamples\",0],[\"GeoAsciiParams\",\"WGS 84\\0\"],[\"ModelTiepoint\",[0,0,0,-180,90,0]],[\"GTModelTypeGeoKey\",2],[\"GTRasterTypeGeoKey\",1],[\"GeographicTypeGeoKey\",4326],[\"GeogCitationGeoKey\",\"WGS 84\"]];function p(r,o){let n,s,a,l;\"number\"==typeof r[0]?(n=o.height||o.ImageLength,a=o.width||o.ImageWidth,s=r.length/(n*a),l=r):(s=r.length,n=r[0].length,a=r[0][0].length,l=[],(0,t.times)(n,e=>{(0,t.times)(a,o=>{(0,t.times)(s,t=>{l.push(r[t][e][o])})})})),o.ImageLength=n,delete o.height,o.ImageWidth=a,delete o.width,o.BitsPerSample||(o.BitsPerSample=(0,t.times)(s,()=>8)),m.forEach(e=>{const t=e[0];if(!o[t]){const r=e[1];o[t]=r}}),o.PhotometricInterpretation||(o.PhotometricInterpretation=3===o.BitsPerSample.length?2:1),o.SamplesPerPixel||(o.SamplesPerPixel=[s]),o.StripByteCounts||(o.StripByteCounts=[s*n*a]),o.ModelPixelScale||(o.ModelPixelScale=[360/a,180/n,0]),o.SampleFormat||(o.SampleFormat=(0,t.times)(s,()=>1));const f=Object.keys(o).filter(e=>(0,t.endsWith)(e,\"GeoKey\")).sort((e,t)=>i[e]-i[t]);if(!o.GeoKeyDirectory){const t=[1,1,0,f.length];f.forEach(r=>{const n=Number(i[r]);let s,a,l;t.push(n),\"SHORT\"===e.fieldTagTypes[n]?(s=1,a=0,l=o[r]):\"GeogCitationGeoKey\"===r?(s=o.GeoAsciiParams.length,a=Number(i.GeoAsciiParams),l=0):console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${r}`),t.push(a),t.push(s),t.push(l)}),o.GeoKeyDirectory=t}for(const e in f)f.hasOwnProperty(e)&&delete o[e];[\"Compression\",\"ExtraSamples\",\"GeographicTypeGeoKey\",\"GTModelTypeGeoKey\",\"GTRasterTypeGeoKey\",\"ImageLength\",\"ImageWidth\",\"PhotometricInterpretation\",\"PlanarConfiguration\",\"ResolutionUnit\",\"SamplesPerPixel\",\"XPosition\",\"YPosition\"].forEach(e=>{o[e]&&(o[e]=h(o[e]))});const p=c(o);return u(l,a,n,p)}\n},{\"./globals\":\"j27V\",\"./utils\":\"FOZT\"}],\"bsJs\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.fromUrl=w,exports.fromArrayBuffer=F,exports.fromFile=D,exports.fromBlob=I,exports.fromUrls=b,exports.writeArrayBuffer=m,Object.defineProperty(exports,\"Pool\",{enumerable:!0,get:function(){return r.default}}),exports.rgb=exports.globals=exports.MultiGeoTIFF=exports.default=exports.GeoTIFF=void 0;var e=c(require(\"./geotiffimage\")),i=c(require(\"./dataview64\")),t=c(require(\"./dataslice\")),r=c(require(\"./pool\")),s=require(\"./source\"),a=f(require(\"./globals\"));exports.globals=a;var n=require(\"./geotiffwriter\"),l=f(require(\"./rgb\"));function o(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return o=function(){return e},e}function f(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var i=o();if(i&&i.has(e))return i.get(e);var t={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if(Object.prototype.hasOwnProperty.call(e,s)){var a=r?Object.getOwnPropertyDescriptor(e,s):null;a&&(a.get||a.set)?Object.defineProperty(t,s,a):t[s]=e[s]}return t.default=e,i&&i.set(e,t),t}function c(e){return e&&e.__esModule?e:{default:e}}function u(e){switch(e){case a.fieldTypes.BYTE:case a.fieldTypes.ASCII:case a.fieldTypes.SBYTE:case a.fieldTypes.UNDEFINED:return 1;case a.fieldTypes.SHORT:case a.fieldTypes.SSHORT:return 2;case a.fieldTypes.LONG:case a.fieldTypes.SLONG:case a.fieldTypes.FLOAT:case a.fieldTypes.IFD:return 4;case a.fieldTypes.RATIONAL:case a.fieldTypes.SRATIONAL:case a.fieldTypes.DOUBLE:case a.fieldTypes.LONG8:case a.fieldTypes.SLONG8:case a.fieldTypes.IFD8:return 8;default:throw new RangeError(`Invalid field type: ${e}`)}}function h(e){const i=e.GeoKeyDirectory;if(!i)return null;const t={};for(let r=4;r<=4*i[3];r+=4){const s=a.geoKeyNames[i[r]],n=i[r+1]?a.fieldTagNames[i[r+1]]:null,l=i[r+2],o=i[r+3];let f=null;if(n){if(null==(f=e[n]))throw new Error(`Could not get value of geoKey '${s}'.`);\"string\"==typeof f?f=f.substring(o,o+l-1):f.subarray&&(f=f.subarray(o,o+l-1))}else f=o;t[s]=f}return t}function d(e,i,t,r){let s=null,n=null;const l=u(i);switch(i){case a.fieldTypes.BYTE:case a.fieldTypes.ASCII:case a.fieldTypes.UNDEFINED:s=new Uint8Array(t),n=e.readUint8;break;case a.fieldTypes.SBYTE:s=new Int8Array(t),n=e.readInt8;break;case a.fieldTypes.SHORT:s=new Uint16Array(t),n=e.readUint16;break;case a.fieldTypes.SSHORT:s=new Int16Array(t),n=e.readInt16;break;case a.fieldTypes.LONG:case a.fieldTypes.IFD:s=new Uint32Array(t),n=e.readUint32;break;case a.fieldTypes.SLONG:s=new Int32Array(t),n=e.readInt32;break;case a.fieldTypes.LONG8:case a.fieldTypes.IFD8:s=new Array(t),n=e.readUint64;break;case a.fieldTypes.SLONG8:s=new Array(t),n=e.readInt64;break;case a.fieldTypes.RATIONAL:s=new Uint32Array(2*t),n=e.readUint32;break;case a.fieldTypes.SRATIONAL:s=new Int32Array(2*t),n=e.readInt32;break;case a.fieldTypes.FLOAT:s=new Float32Array(t),n=e.readFloat32;break;case a.fieldTypes.DOUBLE:s=new Float64Array(t),n=e.readFloat64;break;default:throw new RangeError(`Invalid field type: ${i}`)}if(i!==a.fieldTypes.RATIONAL&&i!==a.fieldTypes.SRATIONAL)for(let a=0;a<t;++a)s[a]=n.call(e,r+a*l);else for(let a=0;a<t;a+=2)s[a]=n.call(e,r+a*l),s[a+1]=n.call(e,r+(a*l+4));return i===a.fieldTypes.ASCII?String.fromCharCode.apply(null,s):s}exports.rgb=l;class g{async readRasters(e={}){const{window:i,width:t,height:r}=e;let{resX:s,resY:a,bbox:n}=e;const l=await this.getImage();let o=l;const f=await this.getImageCount(),c=l.getBoundingBox();if(i&&n)throw new Error('Both \"bbox\" and \"window\" passed.');if(t||r){if(i){const[e,t]=l.getOrigin(),[r,s]=l.getResolution();n=[e+i[0]*r,t+i[1]*s,e+i[2]*r,t+i[3]*s]}const e=n||c;if(t){if(s)throw new Error(\"Both width and resX passed\");s=(e[2]-e[0])/t}if(r){if(a)throw new Error(\"Both width and resY passed\");a=(e[3]-e[1])/r}}if(s||a){const e=[];for(let i=0;i<f;++i){const t=await this.getImage(i),{SubfileType:r,NewSubfileType:s}=t.fileDirectory;(0===i||2===r||1&s)&&e.push(t)}e.sort((e,i)=>e.getWidth()-i.getWidth());for(let i=0;i<e.length;++i){const t=e[i],r=(c[2]-c[0])/t.getWidth(),n=(c[3]-c[1])/t.getHeight();if(o=t,s&&s>r||a&&a>n)break}}let u=i;if(n){const[e,i]=l.getOrigin(),[t,r]=o.getResolution(l);u=[Math.round((n[0]-e)/t),Math.round((n[1]-i)/r),Math.round((n[2]-e)/t),Math.round((n[3]-i)/r)],u=[Math.min(u[0],u[2]),Math.min(u[1],u[3]),Math.max(u[0],u[2]),Math.max(u[1],u[3])]}return o.readRasters({...e,window:u})}}class p extends g{constructor(e,i,t,r,s={}){super(),this.source=e,this.littleEndian=i,this.bigTiff=t,this.firstIFDOffset=r,this.cache=s.cache||!1,this.fileDirectories=null,this.fileDirectoriesParsing=null,this.ghostValues=null}async getSlice(e,i){const r=this.bigTiff?4048:1024;return new t.default(await this.source.fetch(e,void 0!==i?i:r),e,this.littleEndian,this.bigTiff)}async parseFileDirectories(){let e=this.firstIFDOffset;const i=this.bigTiff?8:2,t=this.bigTiff?20:12,r=[];for(;0!==e;){let s=await this.getSlice(e);const n=this.bigTiff?s.readUint64(e):s.readUint16(e),l=n*t+(this.bigTiff?16:6);s.covers(e,l)||(s=await this.getSlice(e,l));const o={};let f=e+(this.bigTiff?8:2);for(let e=0;e<n;f+=t,++e){const e=s.readUint16(f),i=s.readUint16(f+2),t=this.bigTiff?s.readUint64(f+4):s.readUint32(f+4);let r,n;const l=u(i),c=f+(this.bigTiff?12:8);if(l*t<=(this.bigTiff?8:4))r=d(s,i,t,c);else{const e=s.readOffset(c),a=u(i)*t;if(s.covers(e,a))r=d(s,i,t,e);else{r=d(await this.getSlice(e,a),i,t,e)}}n=1===t&&-1===a.arrayFields.indexOf(e)&&i!==a.fieldTypes.RATIONAL&&i!==a.fieldTypes.SRATIONAL?r[0]:r,o[a.fieldTagNames[e]]=n}r.push([o,h(o)]),e=s.readOffset(e+i+t*n)}return r}async getImage(i=0){this.fileDirectories||(this.fileDirectoriesParsing||(this.fileDirectoriesParsing=this.parseFileDirectories()),this.fileDirectories=await this.fileDirectoriesParsing);const t=this.fileDirectories[i];if(!t)throw new RangeError(\"Invalid image index\");return new e.default(t[0],t[1],this.dataView,this.littleEndian,this.cache,this.source)}async getImageCount(){return this.fileDirectories||(this.fileDirectoriesParsing||(this.fileDirectoriesParsing=this.parseFileDirectories()),this.fileDirectories=await this.fileDirectoriesParsing),this.fileDirectories.length}async getGhostValues(){const e=this.bigTiff?16:8;if(this.ghostValues)return this.ghostValues;const i=\"GDAL_STRUCTURAL_METADATA_SIZE=\",t=i.length+100;let r=await this.getSlice(e,t);if(i===d(r,a.fieldTypes.ASCII,i.length,e)){const i=d(r,a.fieldTypes.ASCII,t,e).split(\"\\n\")[0],s=Number(i.split(\"=\")[1].split(\" \")[0])+i.length;s>t&&(r=await this.getSlice(e,s));const n=d(r,a.fieldTypes.ASCII,s,e);this.ghostValues={},n.split(\"\\n\").filter(e=>e.length>0).map(e=>e.split(\"=\")).forEach(([e,i])=>{this.ghostValues[e]=i})}return this.ghostValues}static async fromSource(e,t){const r=await e.fetch(0,1024),s=new i.default(r),a=s.getUint16(0,0);let n;if(18761===a)n=!0;else{if(19789!==a)throw new TypeError(\"Invalid byte order value.\");n=!1}const l=s.getUint16(2,n);let o;if(42===l)o=!1;else{if(43!==l)throw new TypeError(\"Invalid magic number.\");if(o=!0,8!==s.getUint16(4,n))throw new Error(\"Unsupported offset byte-size.\")}const f=o?s.getUint64(8,n):s.getUint32(4,n);return new p(e,n,o,f,t)}close(){return\"function\"==typeof this.source.close&&this.source.close()}}exports.GeoTIFF=p;var y=p;exports.default=y;class T extends g{constructor(e,i){super(),this.mainFile=e,this.overviewFiles=i,this.imageFiles=[e].concat(i),this.fileDirectoriesPerFile=null,this.fileDirectoriesPerFileParsing=null,this.imageCount=null}async parseFileDirectoriesPerFile(){const e=[this.mainFile.parseFileDirectories()].concat(this.overviewFiles.map(e=>e.parseFileDirectories()));return this.fileDirectoriesPerFile=await Promise.all(e),this.fileDirectoriesPerFile}async getImage(i=0){this.fileDirectoriesPerFile||(this.fileDirectoriesPerFileParsing||(this.fileDirectoriesPerFileParsing=this.parseFileDirectoriesPerFile()),this.fileDirectoriesPerFile=await this.fileDirectoriesPerFileParsing);let t=i;for(let r=0;r<this.fileDirectoriesPerFile.length;++r){const i=this.fileDirectoriesPerFile[r];if(t<i.length){const s=this.imageFiles[r];return new e.default(i[t][0],i[t][1],s.dataView,s.littleEndian,s.cache,s.source)}t-=i.length}throw new RangeError(\"Invalid image index\")}async getImageCount(){return this.fileDirectoriesPerFile||(this.fileDirectoriesPerFileParsing||(this.fileDirectoriesPerFileParsing=this.parseFileDirectoriesPerFile()),this.fileDirectoriesPerFile=await this.fileDirectoriesPerFileParsing),this.fileDirectoriesPerFile.reduce((e,i)=>e+i.length,0)}}async function w(e,i={}){return p.fromSource((0,s.makeRemoteSource)(e,i))}async function F(e){return p.fromSource((0,s.makeBufferSource)(e))}async function D(e){return p.fromSource((0,s.makeFileSource)(e))}async function I(e){return p.fromSource((0,s.makeFileReaderSource)(e))}async function b(e,i=[],t={}){const r=await p.fromSource((0,s.makeRemoteSource)(e,t)),a=await Promise.all(i.map(e=>p.fromSource((0,s.makeRemoteSource)(e,t))));return new T(r,a)}async function m(e,i){return(0,n.writeGeotiff)(e,i)}exports.MultiGeoTIFF=T;\n},{\"./geotiffimage\":\"eOWo\",\"./dataview64\":\"dqpX\",\"./dataslice\":\"dGLV\",\"./pool\":\"dHPO\",\"./source\":\"cUx7\",\"./globals\":\"j27V\",\"./geotiffwriter\":\"BGyE\",\"./rgb\":\"fpBl\"}],\"epB2\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0});var e=require(\"./geotiff\");Object.keys(e).forEach(function(t){\"default\"!==t&&\"__esModule\"!==t&&Object.defineProperty(exports,t,{enumerable:!0,get:function(){return e[t]}})});\n},{\"./geotiff\":\"bsJs\"}]},{},[\"epB2\"], null)\n//# sourceMappingURL=/main.js.map\n\n//# sourceURL=webpack://GeoRaster/./node_modules/geotiff/dist-node/main.js?");

/***/ }),

/***/ "./node_modules/worker-loader/dist/workers/InlineWorker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string\n\nvar URL = window.URL || window.webkitURL;\n\nmodule.exports = function (content, url) {\n  try {\n    try {\n      var blob;\n\n      try {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\n        blob = new BlobBuilder();\n\n        blob.append(content);\n\n        blob = blob.getBlob();\n      } catch (e) {\n        // The proposed API\n        blob = new Blob([content]);\n      }\n\n      return new Worker(URL.createObjectURL(blob));\n    } catch (e) {\n      return new Worker('data:application/javascript,' + encodeURIComponent(content));\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error('Inline worker is not supported');\n    }\n\n    return new Worker(url);\n  }\n};\n\n//# sourceURL=webpack://GeoRaster/./node_modules/worker-loader/dist/workers/InlineWorker.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* global Blob */\n/* global URL */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _crossFetch = __webpack_require__(/*! cross-fetch */ \"./node_modules/cross-fetch/dist/node-ponyfill.js\");\n\nvar _crossFetch2 = _interopRequireDefault(_crossFetch);\n\nvar _worker = __webpack_require__(/*! ./worker.js */ \"./src/worker.js\");\n\nvar _worker2 = _interopRequireDefault(_worker);\n\nvar _parseData = __webpack_require__(/*! ./parseData.js */ \"./src/parseData.js\");\n\nvar _parseData2 = _interopRequireDefault(_parseData);\n\nvar _utils = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n\nvar _geotiff = __webpack_require__(/*! geotiff */ \"./node_modules/geotiff/dist-node/main.js\");\n\nvar _georasterToCanvas = __webpack_require__(/*! georaster-to-canvas */ \"./node_modules/georaster-to-canvas/index.js\");\n\nvar _georasterToCanvas2 = _interopRequireDefault(_georasterToCanvas);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction urlExists(url) {\n  try {\n    return (0, _crossFetch2.default)(url, { method: 'HEAD' }).then(function (response) {\n      return response.status === 200;\n    }).catch(function (error) {\n      return false;\n    });\n  } catch (error) {\n    return Promise.resolve(false);\n  }\n}\n\nfunction getValues(geotiff, options) {\n  var left = options.left,\n      top = options.top,\n      right = options.right,\n      bottom = options.bottom,\n      width = options.width,\n      height = options.height;\n  // note this.image and this.geotiff both have a readRasters method;\n  // they are not the same thing. use this.geotiff for experimental version\n  // that reads from best overview\n\n  return geotiff.readRasters({\n    window: [left, top, right, bottom],\n    width: width,\n    height: height,\n    resampleMethod: 'bilinear'\n  }).then(function (rasters) {\n    /*\n      The result appears to be an array with a width and height property set.\n      We only need the values, assuming the user remembers the width and height.\n      Ex: [[0,27723,...11025,12924], width: 10, height: 10]\n    */\n    return rasters.map(function (raster) {\n      return (0, _utils.unflatten)(raster, { height: height, width: width });\n    });\n  });\n};\n\nvar GeoRaster = function () {\n  function GeoRaster(data, metadata, debug) {\n    _classCallCheck(this, GeoRaster);\n\n    if (debug) console.log('starting GeoRaster.constructor with', data, metadata);\n\n    this._web_worker_is_available = typeof window !== 'undefined' && window.Worker !== 'undefined';\n    this._blob_is_available = typeof Blob !== 'undefined';\n    this._url_is_available = typeof URL !== 'undefined';\n\n    // check if should convert to buffer\n    if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && data.constructor && data.constructor.name === 'Buffer' && Buffer.isBuffer(data) === false) {\n      data = new Buffer(data);\n    }\n\n    if (typeof data === 'string') {\n      if (debug) console.log('data is a url');\n      this._data = data;\n      this._url = data;\n      this.rasterType = 'geotiff';\n      this.sourceType = 'url';\n    } else if (typeof Buffer !== 'undefined' && Buffer.isBuffer(data)) {\n      // this is node\n      if (debug) console.log('data is a buffer');\n      this._data = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n      this.rasterType = 'geotiff';\n      this.sourceType = 'Buffer';\n    } else if (data instanceof ArrayBuffer) {\n      // this is browser\n      this._data = data;\n      this.rasterType = 'geotiff';\n      this.sourceType = 'ArrayBuffer';\n    } else if (Array.isArray(data) && metadata) {\n      this._data = data;\n      this.rasterType = 'object';\n      this._metadata = metadata;\n    }\n\n    if (debug) console.log('this after construction:', this);\n  }\n\n  _createClass(GeoRaster, [{\n    key: 'preinitialize',\n    value: function preinitialize(debug) {\n      var _this = this;\n\n      if (debug) console.log('starting preinitialize');\n      if (this._url) {\n        // initialize these outside worker to avoid weird worker error\n        // I don't see how cache option is passed through with fromUrl,\n        // though constantinius says it should work: https://github.com/geotiffjs/geotiff.js/issues/61\n        var ovrURL = this._url + '.ovr';\n        return urlExists(ovrURL).then(function (ovrExists) {\n          if (debug) console.log('overview exists:', ovrExists);\n          if (ovrExists) {\n            return (0, _geotiff.fromUrls)(_this._url, [ovrURL], { cache: true, forceXHR: false });\n          } else {\n            return (0, _geotiff.fromUrl)(_this._url, { cache: true, forceXHR: false });\n          }\n        });\n      } else {\n        // no pre-initialization steps required if not using a Cloud Optimized GeoTIFF\n        return Promise.resolve();\n      }\n    }\n  }, {\n    key: 'initialize',\n    value: function initialize(debug) {\n      var _this2 = this;\n\n      return this.preinitialize(debug).then(function (geotiff) {\n        return new Promise(function (resolve, reject) {\n          if (debug) console.log('starting GeoRaster.initialize');\n          if (debug) console.log('this', _this2);\n\n          if (_this2.rasterType === 'object' || _this2.rasterType === 'geotiff' || _this2.rasterType === 'tiff') {\n            if (_this2._web_worker_is_available) {\n              var worker = new _worker2.default();\n              worker.onmessage = function (e) {\n                if (debug) console.log('main thread received message:', e);\n                var data = e.data;\n                for (var key in data) {\n                  _this2[key] = data[key];\n                }\n                if (_this2._url) {\n                  _this2._geotiff = geotiff;\n                  _this2.getValues = function (options) {\n                    return getValues(this._geotiff, options);\n                  };\n                }\n                _this2.toCanvas = function (options) {\n                  return (0, _georasterToCanvas2.default)(this, options);\n                };\n                resolve(_this2);\n              };\n              if (debug) console.log('about to postMessage');\n              if (_this2._data instanceof ArrayBuffer) {\n                worker.postMessage({\n                  data: _this2._data,\n                  rasterType: _this2.rasterType,\n                  sourceType: _this2.sourceType,\n                  metadata: _this2._metadata\n                }, [_this2._data]);\n              } else {\n                worker.postMessage({\n                  data: _this2._data,\n                  rasterType: _this2.rasterType,\n                  sourceType: _this2.sourceType,\n                  metadata: _this2._metadata\n                });\n              }\n            } else {\n              if (debug) console.log('web worker is not available');\n              (0, _parseData2.default)({\n                data: _this2._data,\n                rasterType: _this2.rasterType,\n                sourceType: _this2.sourceType,\n                metadata: _this2._metadata\n              }, debug).then(function (result) {\n                if (debug) console.log('result:', result);\n                if (_this2._url) {\n                  result._geotiff = geotiff;\n                  result.getValues = function (options) {\n                    return getValues(this._geotiff, options);\n                  };\n                }\n                result.toCanvas = function (options) {\n                  return (0, _georasterToCanvas2.default)(this, options);\n                };\n                resolve(result);\n              }).catch(reject);\n            }\n          } else {\n            reject('couldn\\'t find a way to parse');\n          }\n        });\n      });\n    }\n  }]);\n\n  return GeoRaster;\n}();\n\nvar parseGeoraster = function parseGeoraster(input, metadata, debug) {\n  if (debug) console.log('starting parseGeoraster with ', input, metadata);\n\n  if (input === undefined) {\n    var errorMessage = '[Georaster.parseGeoraster] Error. You passed in undefined to parseGeoraster. We can\\'t make a raster out of nothing!';\n    throw Error(errorMessage);\n  }\n\n  return new GeoRaster(input, metadata, debug).initialize(debug);\n};\n\nif ( true && typeof module.exports !== 'undefined') {\n  module.exports = parseGeoraster;\n}\n\n/*\n    The following code allows you to use GeoRaster without requiring\n*/\nif (typeof window !== 'undefined') {\n  window['parseGeoraster'] = parseGeoraster;\n} else if (typeof self !== 'undefined') {\n  self['parseGeoraster'] = parseGeoraster; // jshint ignore:line\n}\n\n//# sourceURL=webpack://GeoRaster/./src/index.js?");

/***/ }),

/***/ "./src/parseData.js":
/*!**************************!*\
  !*** ./src/parseData.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = parseData;\n\nvar _geotiff = __webpack_require__(/*! geotiff */ \"./node_modules/geotiff/dist-node/main.js\");\n\nvar _utils = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n\nfunction processResult(result, debug) {\n  var noDataValue = result.noDataValue;\n  var height = result.height;\n  var width = result.width;\n\n  return new Promise(function (resolve, reject) {\n    result.maxs = [];\n    result.mins = [];\n    result.ranges = [];\n\n    var max = void 0;var min = void 0;\n\n    // console.log(\"starting to get min, max and ranges\");\n    for (var rasterIndex = 0; rasterIndex < result.numberOfRasters; rasterIndex++) {\n      var rows = result.values[rasterIndex];\n      if (debug) console.log('[georaster] rows:', rows);\n\n      for (var rowIndex = 0; rowIndex < height; rowIndex++) {\n        var row = rows[rowIndex];\n\n        for (var columnIndex = 0; columnIndex < width; columnIndex++) {\n          var value = row[columnIndex];\n          if (value != noDataValue && !isNaN(value)) {\n            if (typeof min === 'undefined' || value < min) min = value;else if (typeof max === 'undefined' || value > max) max = value;\n          }\n        }\n      }\n\n      result.maxs.push(max);\n      result.mins.push(min);\n      result.ranges.push(max - min);\n    }\n\n    resolve(result);\n  });\n}\n\n/* We're not using async because trying to avoid dependency on babel's polyfill\nThere can be conflicts when GeoRaster is used in another project that is also\nusing @babel/polyfill */\nfunction parseData(data, debug) {\n  return new Promise(function (resolve, reject) {\n    try {\n      if (debug) console.log('starting parseData with', data);\n      if (debug) console.log('\\tGeoTIFF:', typeof GeoTIFF === 'undefined' ? 'undefined' : _typeof(GeoTIFF));\n\n      var result = {};\n\n      var height = void 0,\n          width = void 0;\n\n      if (data.rasterType === 'object') {\n        result.values = data.data;\n        result.height = height = data.metadata.height || result.values[0].length;\n        result.width = width = data.metadata.width || result.values[0][0].length;\n        result.pixelHeight = data.metadata.pixelHeight;\n        result.pixelWidth = data.metadata.pixelWidth;\n        result.projection = data.metadata.projection;\n        result.xmin = data.metadata.xmin;\n        result.ymax = data.metadata.ymax;\n        result.noDataValue = data.metadata.noDataValue;\n        result.numberOfRasters = result.values.length;\n        result.xmax = result.xmin + result.width * result.pixelWidth;\n        result.ymin = result.ymax - result.height * result.pixelHeight;\n        result._data = null;\n        resolve(processResult(result));\n      } else if (data.rasterType === 'geotiff') {\n        result._data = data.data;\n\n        var initFunction = _geotiff.fromArrayBuffer;\n        if (data.sourceType === 'url') {\n          initFunction = _geotiff.fromUrl;\n        }\n\n        if (debug) console.log('data.rasterType is geotiff');\n        resolve(initFunction(data.data).then(function (geotiff) {\n          if (debug) console.log('geotiff:', geotiff);\n          return geotiff.getImage().then(function (image) {\n            if (debug) console.log('image:', image);\n\n            var fileDirectory = image.fileDirectory;\n\n            var _image$getGeoKeys = image.getGeoKeys(),\n                GeographicTypeGeoKey = _image$getGeoKeys.GeographicTypeGeoKey,\n                ProjectedCSTypeGeoKey = _image$getGeoKeys.ProjectedCSTypeGeoKey;\n\n            result.projection = GeographicTypeGeoKey || ProjectedCSTypeGeoKey;\n            if (debug) console.log('projection:', result.projection);\n\n            result.height = height = image.getHeight();\n            if (debug) console.log('result.height:', result.height);\n            result.width = width = image.getWidth();\n            if (debug) console.log('result.width:', result.width);\n\n            var _image$getResolution = image.getResolution(),\n                _image$getResolution2 = _slicedToArray(_image$getResolution, 2),\n                resolutionX = _image$getResolution2[0],\n                resolutionY = _image$getResolution2[1];\n\n            result.pixelHeight = Math.abs(resolutionY);\n            result.pixelWidth = Math.abs(resolutionX);\n\n            var _image$getOrigin = image.getOrigin(),\n                _image$getOrigin2 = _slicedToArray(_image$getOrigin, 2),\n                originX = _image$getOrigin2[0],\n                originY = _image$getOrigin2[1];\n\n            result.xmin = originX;\n            result.xmax = result.xmin + width * result.pixelWidth;\n            result.ymax = originY;\n            result.ymin = result.ymax - height * result.pixelHeight;\n\n            result.noDataValue = fileDirectory.GDAL_NODATA ? parseFloat(fileDirectory.GDAL_NODATA) : null;\n\n            result.numberOfRasters = fileDirectory.SamplesPerPixel;\n\n            if (data.sourceType !== 'url') {\n              return image.readRasters().then(function (rasters) {\n                result.values = rasters.map(function (valuesInOneDimension) {\n                  return (0, _utils.unflatten)(valuesInOneDimension, { height: height, width: width });\n                });\n                return processResult(result);\n              });\n            } else {\n              return result;\n            }\n          });\n        }));\n      }\n    } catch (error) {\n      reject(error);\n      console.error('[georaster] error parsing georaster:', error);\n    }\n  });\n}\n\n//# sourceURL=webpack://GeoRaster/./src/parseData.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction countIn1D(array) {\n  return array.reduce(function (counts, value) {\n    if (counts[value] === undefined) {\n      counts[value] = 1;\n    } else {\n      counts[value]++;\n    }\n    return counts;\n  }, {});\n}\n\nfunction countIn2D(rows) {\n  return rows.reduce(function (counts, values) {\n    values.forEach(function (value) {\n      if (counts[value] === undefined) {\n        counts[value] = 1;\n      } else {\n        counts[value]++;\n      }\n    });\n    return counts;\n  }, {});\n}\n\n/*\nTakes in a flattened one dimensional array\nrepresenting two-dimensional pixel values\nand returns an array of arrays.\n*/\nfunction unflatten(valuesInOneDimension, size) {\n  var height = size.height,\n      width = size.width;\n\n  var valuesInTwoDimensions = [];\n  for (var y = 0; y < height; y++) {\n    var start = y * width;\n    var end = start + width;\n    valuesInTwoDimensions.push(valuesInOneDimension.slice(start, end));\n  }\n  return valuesInTwoDimensions;\n}\n\nmodule.exports = { countIn1D: countIn1D, countIn2D: countIn2D, unflatten: unflatten };\n\n//# sourceURL=webpack://GeoRaster/./src/utils.js?");

/***/ }),

/***/ "./src/worker.js":
/*!***********************!*\
  !*** ./src/worker.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function () {\n  return __webpack_require__(/*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */ \"./node_modules/worker-loader/dist/workers/InlineWorker.js\")(\"/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t}\\n/******/ \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// create a fake namespace object\\n/******/ \\t// mode & 1: value is a module id, require it\\n/******/ \\t// mode & 2: merge all properties of value into the ns\\n/******/ \\t// mode & 4: return value when already ns object\\n/******/ \\t// mode & 8|1: behave like require\\n/******/ \\t__webpack_require__.t = function(value, mode) {\\n/******/ \\t\\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \\t\\tif(mode & 8) return value;\\n/******/ \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n/******/ \\t\\tvar ns = Object.create(null);\\n/******/ \\t\\t__webpack_require__.r(ns);\\n/******/ \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n/******/ \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \\t\\treturn ns;\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = \\\"./src/worker.js\\\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \\\"./node_modules/geotiff/dist-node sync recursive\\\":\\n/*!*********************************************!*\\\\\\n  !*** ./node_modules/geotiff/dist-node sync ***!\\n  \\\\*********************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports) {\\n\\neval(\\\"function webpackEmptyContext(req) {\\\\n\\\\tvar e = new Error(\\\\\\\"Cannot find module '\\\\\\\" + req + \\\\\\\"'\\\\\\\");\\\\n\\\\te.code = 'MODULE_NOT_FOUND';\\\\n\\\\tthrow e;\\\\n}\\\\nwebpackEmptyContext.keys = function() { return []; };\\\\nwebpackEmptyContext.resolve = webpackEmptyContext;\\\\nmodule.exports = webpackEmptyContext;\\\\nwebpackEmptyContext.id = \\\\\\\"./node_modules/geotiff/dist-node sync recursive\\\\\\\";\\\\n\\\\n//# sourceURL=webpack://GeoRaster/./node_modules/geotiff/dist-node_sync?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/geotiff/dist-node/main.js\\\":\\n/*!************************************************!*\\\\\\n  !*** ./node_modules/geotiff/dist-node/main.js ***!\\n  \\\\************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\neval(\\\"var require;parcelRequire=function(e,r,t,n){var i,o=\\\\\\\"function\\\\\\\"==typeof parcelRequire&&parcelRequire,u=\\\\\\\"function\\\\\\\"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i=\\\\\\\"function\\\\\\\"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if( true&&\\\\\\\"string\\\\\\\"==typeof t)return __webpack_require__(\\\\\\\"./node_modules/geotiff/dist-node sync recursive\\\\\\\")(t);var c=new Error(\\\\\\\"Cannot find module '\\\\\\\"+t+\\\\\\\"'\\\\\\\");throw c.code=\\\\\\\"MODULE_NOT_FOUND\\\\\\\",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]); true?module.exports=l:undefined}if(parcelRequire=f,i)throw i;return f}({\\\\\\\"j27V\\\\\\\":[function(require,module,exports) {\\\\n\\\\\\\"use strict\\\\\\\";Object.defineProperty(exports,\\\\\\\"__esModule\\\\\\\",{value:!0}),exports.geoKeys=exports.geoKeyNames=exports.ExtraSamplesValues=exports.photometricInterpretations=exports.fieldTypes=exports.fieldTypeNames=exports.arrayFields=exports.fieldTagTypes=exports.fieldTags=exports.fieldTagNames=void 0;const e={315:\\\\\\\"Artist\\\\\\\",258:\\\\\\\"BitsPerSample\\\\\\\",265:\\\\\\\"CellLength\\\\\\\",264:\\\\\\\"CellWidth\\\\\\\",320:\\\\\\\"ColorMap\\\\\\\",259:\\\\\\\"Compression\\\\\\\",33432:\\\\\\\"Copyright\\\\\\\",306:\\\\\\\"DateTime\\\\\\\",338:\\\\\\\"ExtraSamples\\\\\\\",266:\\\\\\\"FillOrder\\\\\\\",289:\\\\\\\"FreeByteCounts\\\\\\\",288:\\\\\\\"FreeOffsets\\\\\\\",291:\\\\\\\"GrayResponseCurve\\\\\\\",290:\\\\\\\"GrayResponseUnit\\\\\\\",316:\\\\\\\"HostComputer\\\\\\\",270:\\\\\\\"ImageDescription\\\\\\\",257:\\\\\\\"ImageLength\\\\\\\",256:\\\\\\\"ImageWidth\\\\\\\",271:\\\\\\\"Make\\\\\\\",281:\\\\\\\"MaxSampleValue\\\\\\\",280:\\\\\\\"MinSampleValue\\\\\\\",272:\\\\\\\"Model\\\\\\\",254:\\\\\\\"NewSubfileType\\\\\\\",274:\\\\\\\"Orientation\\\\\\\",262:\\\\\\\"PhotometricInterpretation\\\\\\\",284:\\\\\\\"PlanarConfiguration\\\\\\\",296:\\\\\\\"ResolutionUnit\\\\\\\",278:\\\\\\\"RowsPerStrip\\\\\\\",277:\\\\\\\"SamplesPerPixel\\\\\\\",305:\\\\\\\"Software\\\\\\\",279:\\\\\\\"StripByteCounts\\\\\\\",273:\\\\\\\"StripOffsets\\\\\\\",255:\\\\\\\"SubfileType\\\\\\\",263:\\\\\\\"Threshholding\\\\\\\",282:\\\\\\\"XResolution\\\\\\\",283:\\\\\\\"YResolution\\\\\\\",326:\\\\\\\"BadFaxLines\\\\\\\",327:\\\\\\\"CleanFaxData\\\\\\\",343:\\\\\\\"ClipPath\\\\\\\",328:\\\\\\\"ConsecutiveBadFaxLines\\\\\\\",433:\\\\\\\"Decode\\\\\\\",434:\\\\\\\"DefaultImageColor\\\\\\\",269:\\\\\\\"DocumentName\\\\\\\",336:\\\\\\\"DotRange\\\\\\\",321:\\\\\\\"HalftoneHints\\\\\\\",346:\\\\\\\"Indexed\\\\\\\",347:\\\\\\\"JPEGTables\\\\\\\",285:\\\\\\\"PageName\\\\\\\",297:\\\\\\\"PageNumber\\\\\\\",317:\\\\\\\"Predictor\\\\\\\",319:\\\\\\\"PrimaryChromaticities\\\\\\\",532:\\\\\\\"ReferenceBlackWhite\\\\\\\",339:\\\\\\\"SampleFormat\\\\\\\",340:\\\\\\\"SMinSampleValue\\\\\\\",341:\\\\\\\"SMaxSampleValue\\\\\\\",559:\\\\\\\"StripRowCounts\\\\\\\",330:\\\\\\\"SubIFDs\\\\\\\",292:\\\\\\\"T4Options\\\\\\\",293:\\\\\\\"T6Options\\\\\\\",325:\\\\\\\"TileByteCounts\\\\\\\",323:\\\\\\\"TileLength\\\\\\\",324:\\\\\\\"TileOffsets\\\\\\\",322:\\\\\\\"TileWidth\\\\\\\",301:\\\\\\\"TransferFunction\\\\\\\",318:\\\\\\\"WhitePoint\\\\\\\",344:\\\\\\\"XClipPathUnits\\\\\\\",286:\\\\\\\"XPosition\\\\\\\",529:\\\\\\\"YCbCrCoefficients\\\\\\\",531:\\\\\\\"YCbCrPositioning\\\\\\\",530:\\\\\\\"YCbCrSubSampling\\\\\\\",345:\\\\\\\"YClipPathUnits\\\\\\\",287:\\\\\\\"YPosition\\\\\\\",37378:\\\\\\\"ApertureValue\\\\\\\",40961:\\\\\\\"ColorSpace\\\\\\\",36868:\\\\\\\"DateTimeDigitized\\\\\\\",36867:\\\\\\\"DateTimeOriginal\\\\\\\",34665:\\\\\\\"Exif IFD\\\\\\\",36864:\\\\\\\"ExifVersion\\\\\\\",33434:\\\\\\\"ExposureTime\\\\\\\",41728:\\\\\\\"FileSource\\\\\\\",37385:\\\\\\\"Flash\\\\\\\",40960:\\\\\\\"FlashpixVersion\\\\\\\",33437:\\\\\\\"FNumber\\\\\\\",42016:\\\\\\\"ImageUniqueID\\\\\\\",37384:\\\\\\\"LightSource\\\\\\\",37500:\\\\\\\"MakerNote\\\\\\\",37377:\\\\\\\"ShutterSpeedValue\\\\\\\",37510:\\\\\\\"UserComment\\\\\\\",33723:\\\\\\\"IPTC\\\\\\\",34675:\\\\\\\"ICC Profile\\\\\\\",700:\\\\\\\"XMP\\\\\\\",42112:\\\\\\\"GDAL_METADATA\\\\\\\",42113:\\\\\\\"GDAL_NODATA\\\\\\\",34377:\\\\\\\"Photoshop\\\\\\\",33550:\\\\\\\"ModelPixelScale\\\\\\\",33922:\\\\\\\"ModelTiepoint\\\\\\\",34264:\\\\\\\"ModelTransformation\\\\\\\",34735:\\\\\\\"GeoKeyDirectory\\\\\\\",34736:\\\\\\\"GeoDoubleParams\\\\\\\",34737:\\\\\\\"GeoAsciiParams\\\\\\\"};exports.fieldTagNames=e;const o={};exports.fieldTags=o;for(const G in e)e.hasOwnProperty(G)&&(o[e[G]]=parseInt(G,10));const t={256:\\\\\\\"SHORT\\\\\\\",257:\\\\\\\"SHORT\\\\\\\",258:\\\\\\\"SHORT\\\\\\\",259:\\\\\\\"SHORT\\\\\\\",262:\\\\\\\"SHORT\\\\\\\",273:\\\\\\\"LONG\\\\\\\",274:\\\\\\\"SHORT\\\\\\\",277:\\\\\\\"SHORT\\\\\\\",278:\\\\\\\"LONG\\\\\\\",279:\\\\\\\"LONG\\\\\\\",282:\\\\\\\"RATIONAL\\\\\\\",283:\\\\\\\"RATIONAL\\\\\\\",284:\\\\\\\"SHORT\\\\\\\",286:\\\\\\\"SHORT\\\\\\\",287:\\\\\\\"RATIONAL\\\\\\\",296:\\\\\\\"SHORT\\\\\\\",305:\\\\\\\"ASCII\\\\\\\",306:\\\\\\\"ASCII\\\\\\\",338:\\\\\\\"SHORT\\\\\\\",339:\\\\\\\"SHORT\\\\\\\",513:\\\\\\\"LONG\\\\\\\",514:\\\\\\\"LONG\\\\\\\",1024:\\\\\\\"SHORT\\\\\\\",1025:\\\\\\\"SHORT\\\\\\\",2048:\\\\\\\"SHORT\\\\\\\",2049:\\\\\\\"ASCII\\\\\\\",33550:\\\\\\\"DOUBLE\\\\\\\",33922:\\\\\\\"DOUBLE\\\\\\\",34665:\\\\\\\"LONG\\\\\\\",34735:\\\\\\\"SHORT\\\\\\\",34737:\\\\\\\"ASCII\\\\\\\",42113:\\\\\\\"ASCII\\\\\\\"};exports.fieldTagTypes=t;const i=[o.BitsPerSample,o.ExtraSamples,o.SampleFormat,o.StripByteCounts,o.StripOffsets,o.StripRowCounts,o.TileByteCounts,o.TileOffsets];exports.arrayFields=i;const r={1:\\\\\\\"BYTE\\\\\\\",2:\\\\\\\"ASCII\\\\\\\",3:\\\\\\\"SHORT\\\\\\\",4:\\\\\\\"LONG\\\\\\\",5:\\\\\\\"RATIONAL\\\\\\\",6:\\\\\\\"SBYTE\\\\\\\",7:\\\\\\\"UNDEFINED\\\\\\\",8:\\\\\\\"SSHORT\\\\\\\",9:\\\\\\\"SLONG\\\\\\\",10:\\\\\\\"SRATIONAL\\\\\\\",11:\\\\\\\"FLOAT\\\\\\\",12:\\\\\\\"DOUBLE\\\\\\\",13:\\\\\\\"IFD\\\\\\\",16:\\\\\\\"LONG8\\\\\\\",17:\\\\\\\"SLONG8\\\\\\\",18:\\\\\\\"IFD8\\\\\\\"};exports.fieldTypeNames=r;const a={};exports.fieldTypes=a;for(const G in r)r.hasOwnProperty(G)&&(a[r[G]]=parseInt(G,10));const s={WhiteIsZero:0,BlackIsZero:1,RGB:2,Palette:3,TransparencyMask:4,CMYK:5,YCbCr:6,CIELab:8,ICCLab:9};exports.photometricInterpretations=s;const n={Unspecified:0,Assocalpha:1,Unassalpha:2};exports.ExtraSamplesValues=n;const l={1024:\\\\\\\"GTModelTypeGeoKey\\\\\\\",1025:\\\\\\\"GTRasterTypeGeoKey\\\\\\\",1026:\\\\\\\"GTCitationGeoKey\\\\\\\",2048:\\\\\\\"GeographicTypeGeoKey\\\\\\\",2049:\\\\\\\"GeogCitationGeoKey\\\\\\\",2050:\\\\\\\"GeogGeodeticDatumGeoKey\\\\\\\",2051:\\\\\\\"GeogPrimeMeridianGeoKey\\\\\\\",2052:\\\\\\\"GeogLinearUnitsGeoKey\\\\\\\",2053:\\\\\\\"GeogLinearUnitSizeGeoKey\\\\\\\",2054:\\\\\\\"GeogAngularUnitsGeoKey\\\\\\\",2055:\\\\\\\"GeogAngularUnitSizeGeoKey\\\\\\\",2056:\\\\\\\"GeogEllipsoidGeoKey\\\\\\\",2057:\\\\\\\"GeogSemiMajorAxisGeoKey\\\\\\\",2058:\\\\\\\"GeogSemiMinorAxisGeoKey\\\\\\\",2059:\\\\\\\"GeogInvFlatteningGeoKey\\\\\\\",2060:\\\\\\\"GeogAzimuthUnitsGeoKey\\\\\\\",2061:\\\\\\\"GeogPrimeMeridianLongGeoKey\\\\\\\",2062:\\\\\\\"GeogTOWGS84GeoKey\\\\\\\",3072:\\\\\\\"ProjectedCSTypeGeoKey\\\\\\\",3073:\\\\\\\"PCSCitationGeoKey\\\\\\\",3074:\\\\\\\"ProjectionGeoKey\\\\\\\",3075:\\\\\\\"ProjCoordTransGeoKey\\\\\\\",3076:\\\\\\\"ProjLinearUnitsGeoKey\\\\\\\",3077:\\\\\\\"ProjLinearUnitSizeGeoKey\\\\\\\",3078:\\\\\\\"ProjStdParallel1GeoKey\\\\\\\",3079:\\\\\\\"ProjStdParallel2GeoKey\\\\\\\",3080:\\\\\\\"ProjNatOriginLongGeoKey\\\\\\\",3081:\\\\\\\"ProjNatOriginLatGeoKey\\\\\\\",3082:\\\\\\\"ProjFalseEastingGeoKey\\\\\\\",3083:\\\\\\\"ProjFalseNorthingGeoKey\\\\\\\",3084:\\\\\\\"ProjFalseOriginLongGeoKey\\\\\\\",3085:\\\\\\\"ProjFalseOriginLatGeoKey\\\\\\\",3086:\\\\\\\"ProjFalseOriginEastingGeoKey\\\\\\\",3087:\\\\\\\"ProjFalseOriginNorthingGeoKey\\\\\\\",3088:\\\\\\\"ProjCenterLongGeoKey\\\\\\\",3089:\\\\\\\"ProjCenterLatGeoKey\\\\\\\",3090:\\\\\\\"ProjCenterEastingGeoKey\\\\\\\",3091:\\\\\\\"ProjCenterNorthingGeoKey\\\\\\\",3092:\\\\\\\"ProjScaleAtNatOriginGeoKey\\\\\\\",3093:\\\\\\\"ProjScaleAtCenterGeoKey\\\\\\\",3094:\\\\\\\"ProjAzimuthAngleGeoKey\\\\\\\",3095:\\\\\\\"ProjStraightVertPoleLongGeoKey\\\\\\\",3096:\\\\\\\"ProjRectifiedGridAngleGeoKey\\\\\\\",4096:\\\\\\\"VerticalCSTypeGeoKey\\\\\\\",4097:\\\\\\\"VerticalCitationGeoKey\\\\\\\",4098:\\\\\\\"VerticalDatumGeoKey\\\\\\\",4099:\\\\\\\"VerticalUnitsGeoKey\\\\\\\"};exports.geoKeyNames=l;const p={};exports.geoKeys=p;for(const G in l)l.hasOwnProperty(G)&&(p[l[G]]=parseInt(G,10));\\\\n},{}],\\\\\\\"fpBl\\\\\\\":[function(require,module,exports) {\\\\n\\\\\\\"use strict\\\\\\\";function t(t,e){const{width:n,height:r}=t,o=new Uint8Array(n*r*3);let h;for(let i=0,l=0;i<t.length;++i,l+=3)h=256-t[i]/e*256,o[l]=h,o[l+1]=h,o[l+2]=h;return o}function e(t,e){const{width:n,height:r}=t,o=new Uint8Array(n*r*3);let h;for(let i=0,l=0;i<t.length;++i,l+=3)h=t[i]/e*256,o[l]=h,o[l+1]=h,o[l+2]=h;return o}function n(t,e){const{width:n,height:r}=t,o=new Uint8Array(n*r*3),h=e.length/3,i=e.length/3*2;for(let l=0,s=0;l<t.length;++l,s+=3){const n=t[l];o[s]=e[n]/65536*256,o[s+1]=e[n+h]/65536*256,o[s+2]=e[n+i]/65536*256}return o}function r(t){const{width:e,height:n}=t,r=new Uint8Array(e*n*3);for(let o=0,h=0;o<t.length;o+=4,h+=3){const e=t[o],n=t[o+1],i=t[o+2],l=t[o+3];r[h]=(255-e)/256*255*((255-l)/256),r[h+1]=(255-n)/256*255*((255-l)/256),r[h+2]=(255-i)/256*255*((255-l)/256)}return r}function o(t){const{width:e,height:n}=t,r=new Uint8ClampedArray(e*n*3);for(let o=0,h=0;o<t.length;o+=3,h+=3){const e=t[o],n=t[o+1],i=t[o+2];r[h]=e+1.402*(i-128),r[h+1]=e-.34414*(n-128)-.71414*(i-128),r[h+2]=e+1.772*(n-128)}return r}Object.defineProperty(exports,\\\\\\\"__esModule\\\\\\\",{value:!0}),exports.fromWhiteIsZero=t,exports.fromBlackIsZero=e,exports.fromPalette=n,exports.fromCMYK=r,exports.fromYCbCr=o,exports.fromCIELab=s;const h=.95047,i=1,l=1.08883;function s(t){const{width:e,height:n}=t,r=new Uint8Array(e*n*3);for(let o=0,s=0;o<t.length;o+=3,s+=3){let e,n,a,c=(t[o+0]+16)/116,f=(t[o+1]<<24>>24)/500+c,u=c-(t[o+2]<<24>>24)/200;e=(e=3.2406*(f=h*(f*f*f>.008856?f*f*f:(f-16/116)/7.787))+-1.5372*(c=i*(c*c*c>.008856?c*c*c:(c-16/116)/7.787))+-.4986*(u=l*(u*u*u>.008856?u*u*u:(u-16/116)/7.787)))>.0031308?1.055*e**(1/2.4)-.055:12.92*e,n=(n=-.9689*f+1.8758*c+.0415*u)>.0031308?1.055*n**(1/2.4)-.055:12.92*n,a=(a=.0557*f+-.204*c+1.057*u)>.0031308?1.055*a**(1/2.4)-.055:12.92*a,r[s]=255*Math.max(0,Math.min(1,e)),r[s+1]=255*Math.max(0,Math.min(1,n)),r[s+2]=255*Math.max(0,Math.min(1,a))}return r}\\\\n},{}],\\\\\\\"IKSA\\\\\\\":[function(require,module,exports) {\\\\n\\\\\\\"use strict\\\\\\\";function e(e,t){let r=e.length-t,o=0;do{for(let r=t;r>0;r--)e[o+t]+=e[o],o++;r-=t}while(r>0)}function t(e,t,r){let o=0,n=e.length;const i=n/r;for(;n>t;){for(let r=t;r>0;--r)e[o+t]+=e[o],++o;n-=t}const l=e.slice();for(let s=0;s<i;++s)for(let t=0;t<r;++t)e[r*s+t]=l[(r-t-1)*i+s]}function r(r,o,n,i,l,s){if(!o||1===o)return r;for(let e=0;e<l.length;++e){if(l[e]%8!=0)throw new Error(\\\\\\\"When decoding with predictor, only multiple of 8 bits are supported.\\\\\\\");if(l[e]!==l[0])throw new Error(\\\\\\\"When decoding with predictor, all samples must have the same size.\\\\\\\")}const a=l[0]/8,c=2===s?1:l.length;for(let f=0;f<i&&!(f*c*n*a>=r.byteLength);++f){let i;if(2===o){switch(l[0]){case 8:i=new Uint8Array(r,f*c*n*a,c*n*a);break;case 16:i=new Uint16Array(r,f*c*n*a,c*n*a/2);break;case 32:i=new Uint32Array(r,f*c*n*a,c*n*a/4);break;default:throw new Error(`Predictor 2 not allowed with ${l[0]} bits per sample.`)}e(i,c,a)}else 3===o&&t(i=new Uint8Array(r,f*c*n*a,c*n*a),c,a)}return r}Object.defineProperty(exports,\\\\\\\"__esModule\\\\\\\",{value:!0}),exports.applyPredictor=r;\\\\n},{}],\\\\\\\"FJDe\\\\\\\":[function(require,module,exports) {\\\\n\\\\\\\"use strict\\\\\\\";Object.defineProperty(exports,\\\\\\\"__esModule\\\\\\\",{value:!0}),exports.default=void 0;var e=require(\\\\\\\"../predictor\\\\\\\");class t{decode(t,r){const i=this.decodeBlock(r),o=t.Predictor||1;if(1!==o){const r=!t.StripOffsets,s=r?t.TileWidth:t.ImageWidth,d=r?t.TileLength:t.RowsPerStrip||t.ImageLength;return(0,e.applyPredictor)(i,o,s,d,t.BitsPerSample,t.PlanarConfiguration)}return i}}exports.default=t;\\\\n},{\\\\\\\"../predictor\\\\\\\":\\\\\\\"IKSA\\\\\\\"}],\\\\\\\"V9bQ\\\\\\\":[function(require,module,exports) {\\\\n\\\\\\\"use strict\\\\\\\";Object.defineProperty(exports,\\\\\\\"__esModule\\\\\\\",{value:!0}),exports.default=void 0;var e=t(require(\\\\\\\"./basedecoder\\\\\\\"));function t(e){return e&&e.__esModule?e:{default:e}}class r extends e.default{decodeBlock(e){return e}}exports.default=r;\\\\n},{\\\\\\\"./basedecoder\\\\\\\":\\\\\\\"FJDe\\\\\\\"}],\\\\\\\"tcId\\\\\\\":[function(require,module,exports) {\\\\n\\\\\\\"use strict\\\\\\\";Object.defineProperty(exports,\\\\\\\"__esModule\\\\\\\",{value:!0}),exports.default=void 0;var e=t(require(\\\\\\\"./basedecoder\\\\\\\"));function t(e){return e&&e.__esModule?e:{default:e}}const n=9,r=256,o=257,f=12;function i(e,t,n){const r=t%8,f=Math.floor(t/8),i=8-r,u=t+n-8*(f+1);let c=8*(f+2)-(t+n);const s=8*(f+2)-t;if(c=Math.max(0,c),f>=e.length)return console.warn(\\\\\\\"ran off the end of the buffer before finding EOI_CODE (end on input code)\\\\\\\"),o;let l=e[f]&2**(8-r)-1,a=l<<=n-i;if(f+1<e.length){let t=e[f+1]>>>c;a+=t<<=Math.max(0,n-s)}if(u>8&&f+2<e.length){const r=8*(f+3)-(t+n);a+=e[f+2]>>>r}return a}function u(e,t){for(let n=t.length-1;n>=0;n--)e.push(t[n]);return e}function c(e){const t=new Uint16Array(4093),c=new Uint8Array(4093);for(let n=0;n<=257;n++)t[n]=4096,c[n]=n;let s=258,l=n,a=0;function d(){s=258,l=n}function h(e){const t=i(e,a,l);return a+=l,t}function p(e,n){return c[s]=n,t[s]=e,++s-1}function g(e){const n=[];for(let r=e;4096!==r;r=t[r])n.push(c[r]);return n}const w=[];d();const y=new Uint8Array(e);let b,x=h(y);for(;x!==o;){if(x===r){for(d(),x=h(y);x===r;)x=h(y);if(x===o)break;if(x>r)throw new Error(`corrupted code at scanline ${x}`);u(w,g(x)),b=x}else if(x<s){const e=g(x);u(w,e),p(b,e[e.length-1]),b=x}else{const e=g(b);if(!e)throw new Error(`Bogus entry. Not in dictionary, ${b} / ${s}, position: ${a}`);u(w,e),w.push(e[e.length-1]),p(b,e[e.length-1]),b=x}s+1>=2**l&&(l===f?b=void 0:l++),x=h(y)}return new Uint8Array(w)}class s extends e.default{decodeBlock(e){return c(e,!1).buffer}}exports.default=s;\\\\n},{\\\\\\\"./basedecoder\\\\\\\":\\\\\\\"FJDe\\\\\\\"}],\\\\\\\"J7kk\\\\\\\":[function(require,module,exports) {\\\\n\\\\\\\"use strict\\\\\\\";Object.defineProperty(exports,\\\\\\\"__esModule\\\\\\\",{value:!0}),exports.default=void 0;var e=n(require(\\\\\\\"./basedecoder\\\\\\\"));function n(e){return e&&e.__esModule?e:{default:e}}const t=new Int32Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]),r=4017,s=799,o=3406,a=2276,c=1567,i=3784,l=5793,f=2896;function u(e,n){let t=0;const r=[];let s=16;for(;s>0&&!e[s-1];)--s;r.push({children:[],index:0});let o,a=r[0];for(let c=0;c<s;c++){for(let s=0;s<e[c];s++){for((a=r.pop()).children[a.index]=n[t];a.index>0;)a=r.pop();for(a.index++,r.push(a);r.length<=c;)r.push(o={children:[],index:0}),a.children[a.index]=o.children,a=o;t++}c+1<s&&(r.push(o={children:[],index:0}),a.children[a.index]=o.children,a=o)}return r[0].children}function h(e,n,r,s,o,a,c,i,l){const{mcusPerLine:f,progressive:u}=r,h=n;let m=n,d=0,b=0;function p(){if(b>0)return d>>--b&1;if(255===(d=e[m++])){const n=e[m++];if(n)throw new Error(`unexpected marker: ${(d<<8|n).toString(16)}`)}return b=7,d>>>7}function w(e){let n,t=e;for(;null!==(n=p());){if(\\\\\\\"number\\\\\\\"==typeof(t=t[n]))return t;if(\\\\\\\"object\\\\\\\"!=typeof t)throw new Error(\\\\\\\"invalid huffman sequence\\\\\\\")}return null}function k(e){let n=e,t=0;for(;n>0;){const e=p();if(null===e)return;t=t<<1|e,--n}return t}function x(e){const n=k(e);return n>=1<<e-1?n:n+(-1<<e)+1}let y=0;let P,v=0;function T(e,n,t,r,s){const o=t%f,a=(t/f|0)*e.v+r,c=o*e.h+s;n(e,e.blocks[a][c])}function C(e,n,t){const r=t/e.blocksPerLine|0,s=t%e.blocksPerLine;n(e,e.blocks[r][s])}const g=s.length;let A,L,E,q,D,I;I=u?0===a?0===i?function(e,n){const t=w(e.huffmanTableDC),r=0===t?0:x(t)<<l;e.pred+=r,n[0]=e.pred}:function(e,n){n[0]|=p()<<l}:0===i?function(e,n){if(y>0)return void y--;let r=a;const s=c;for(;r<=s;){const s=w(e.huffmanTableAC),o=15&s,a=s>>4;if(0===o){if(a<15){y=k(a)+(1<<a)-1;break}r+=16}else n[t[r+=a]]=x(o)*(1<<l),r++}}:function(e,n){let r=a;const s=c;let o=0;for(;r<=s;){const s=t[r],a=n[s]<0?-1:1;switch(v){case 0:{const n=w(e.huffmanTableAC),t=15&n;if(o=n>>4,0===t)o<15?(y=k(o)+(1<<o),v=4):(o=16,v=1);else{if(1!==t)throw new Error(\\\\\\\"invalid ACn encoding\\\\\\\");P=x(t),v=o?2:3}continue}case 1:case 2:n[s]?n[s]+=(p()<<l)*a:0==--o&&(v=2===v?3:0);break;case 3:n[s]?n[s]+=(p()<<l)*a:(n[s]=P<<l,v=0);break;case 4:n[s]&&(n[s]+=(p()<<l)*a)}r++}4===v&&0==--y&&(v=0)}:function(e,n){const r=w(e.huffmanTableDC),s=0===r?0:x(r);e.pred+=s,n[0]=e.pred;let o=1;for(;o<64;){const r=w(e.huffmanTableAC),s=15&r,a=r>>4;if(0===s){if(a<15)break;o+=16}else n[t[o+=a]]=x(s),o++}};let z,M,O=0;M=1===g?s[0].blocksPerLine*s[0].blocksPerColumn:f*r.mcusPerColumn;const U=o||M;for(;O<M;){for(L=0;L<g;L++)s[L].pred=0;if(y=0,1===g)for(A=s[0],D=0;D<U;D++)C(A,I,O),O++;else for(D=0;D<U;D++){for(L=0;L<g;L++){A=s[L];const{h:e,v:n}=A;for(E=0;E<n;E++)for(q=0;q<e;q++)T(A,I,O,E,q)}if(++O===M)break}if(b=0,(z=e[m]<<8|e[m+1])<65280)throw new Error(\\\\\\\"marker was not found\\\\\\\");if(!(z>=65488&&z<=65495))break;m+=2}return m-h}function m(e,n){const t=[],{blocksPerLine:u,blocksPerColumn:h}=n,m=u<<3,d=new Int32Array(64),b=new Uint8Array(64);function p(e,t,u){const h=n.quantizationTable;let m,d,b,p,w,k,x,y,P;const v=u;let T;for(T=0;T<64;T++)v[T]=e[T]*h[T];for(T=0;T<8;++T){const e=8*T;0!==v[1+e]||0!==v[2+e]||0!==v[3+e]||0!==v[4+e]||0!==v[5+e]||0!==v[6+e]||0!==v[7+e]?(m=l*v[0+e]+128>>8,d=l*v[4+e]+128>>8,b=v[2+e],p=v[6+e],w=f*(v[1+e]-v[7+e])+128>>8,y=f*(v[1+e]+v[7+e])+128>>8,k=v[3+e]<<4,x=v[5+e]<<4,P=m-d+1>>1,m=m+d+1>>1,d=P,P=b*i+p*c+128>>8,b=b*c-p*i+128>>8,p=P,P=w-x+1>>1,w=w+x+1>>1,x=P,P=y+k+1>>1,k=y-k+1>>1,y=P,P=m-p+1>>1,m=m+p+1>>1,p=P,P=d-b+1>>1,d=d+b+1>>1,b=P,P=w*a+y*o+2048>>12,w=w*o-y*a+2048>>12,y=P,P=k*s+x*r+2048>>12,k=k*r-x*s+2048>>12,x=P,v[0+e]=m+y,v[7+e]=m-y,v[1+e]=d+x,v[6+e]=d-x,v[2+e]=b+k,v[5+e]=b-k,v[3+e]=p+w,v[4+e]=p-w):(P=l*v[0+e]+512>>10,v[0+e]=P,v[1+e]=P,v[2+e]=P,v[3+e]=P,v[4+e]=P,v[5+e]=P,v[6+e]=P,v[7+e]=P)}for(T=0;T<8;++T){const e=T;0!==v[8+e]||0!==v[16+e]||0!==v[24+e]||0!==v[32+e]||0!==v[40+e]||0!==v[48+e]||0!==v[56+e]?(m=l*v[0+e]+2048>>12,d=l*v[32+e]+2048>>12,b=v[16+e],p=v[48+e],w=f*(v[8+e]-v[56+e])+2048>>12,y=f*(v[8+e]+v[56+e])+2048>>12,k=v[24+e],x=v[40+e],P=m-d+1>>1,m=m+d+1>>1,d=P,P=b*i+p*c+2048>>12,b=b*c-p*i+2048>>12,p=P,P=w-x+1>>1,w=w+x+1>>1,x=P,P=y+k+1>>1,k=y-k+1>>1,y=P,P=m-p+1>>1,m=m+p+1>>1,p=P,P=d-b+1>>1,d=d+b+1>>1,b=P,P=w*a+y*o+2048>>12,w=w*o-y*a+2048>>12,y=P,P=k*s+x*r+2048>>12,k=k*r-x*s+2048>>12,x=P,v[0+e]=m+y,v[56+e]=m-y,v[8+e]=d+x,v[48+e]=d-x,v[16+e]=b+k,v[40+e]=b-k,v[24+e]=p+w,v[32+e]=p-w):(P=l*u[T+0]+8192>>14,v[0+e]=P,v[8+e]=P,v[16+e]=P,v[24+e]=P,v[32+e]=P,v[40+e]=P,v[48+e]=P,v[56+e]=P)}for(T=0;T<64;++T){const e=128+(v[T]+8>>4);t[T]=e<0?0:e>255?255:e}}for(let r=0;r<h;r++){const e=r<<3;for(let n=0;n<8;n++)t.push(new Uint8Array(m));for(let s=0;s<u;s++){p(n.blocks[r][s],b,d);let o=0;const a=s<<3;for(let n=0;n<8;n++){const r=t[e+n];for(let e=0;e<8;e++)r[a+e]=b[o++]}}}return t}class d{constructor(){this.jfif=null,this.adobe=null,this.quantizationTables=[],this.huffmanTablesAC=[],this.huffmanTablesDC=[],this.resetFrames()}resetFrames(){this.frames=[]}parse(e){let n=0;function r(){const t=e[n]<<8|e[n+1];return n+=2,t}function s(){const t=r(),s=e.subarray(n,n+t-2);return n+=s.length,s}function o(e){let n,t,r=0,s=0;for(t in e.components)e.components.hasOwnProperty(t)&&(r<(n=e.components[t]).h&&(r=n.h),s<n.v&&(s=n.v));const o=Math.ceil(e.samplesPerLine/8/r),a=Math.ceil(e.scanLines/8/s);for(t in e.components)if(e.components.hasOwnProperty(t)){n=e.components[t];const c=Math.ceil(Math.ceil(e.samplesPerLine/8)*n.h/r),i=Math.ceil(Math.ceil(e.scanLines/8)*n.v/s),l=o*n.h,f=a*n.v,u=[];for(let e=0;e<f;e++){const e=[];for(let n=0;n<l;n++)e.push(new Int32Array(64));u.push(e)}n.blocksPerLine=c,n.blocksPerColumn=i,n.blocks=u}e.maxH=r,e.maxV=s,e.mcusPerLine=o,e.mcusPerColumn=a}let a=r();if(65496!==a)throw new Error(\\\\\\\"SOI not found\\\\\\\");for(a=r();65497!==a;){switch(a){case 65280:break;case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:{const e=s();65504===a&&74===e[0]&&70===e[1]&&73===e[2]&&70===e[3]&&0===e[4]&&(this.jfif={version:{major:e[5],minor:e[6]},densityUnits:e[7],xDensity:e[8]<<8|e[9],yDensity:e[10]<<8|e[11],thumbWidth:e[12],thumbHeight:e[13],thumbData:e.subarray(14,14+3*e[12]*e[13])}),65518===a&&65===e[0]&&100===e[1]&&111===e[2]&&98===e[3]&&101===e[4]&&0===e[5]&&(this.adobe={version:e[6],flags0:e[7]<<8|e[8],flags1:e[9]<<8|e[10],transformCode:e[11]});break}case 65499:{const s=r()+n-2;for(;n<s;){const s=e[n++],o=new Int32Array(64);if(s>>4==0)for(let r=0;r<64;r++){o[t[r]]=e[n++]}else{if(s>>4!=1)throw new Error(\\\\\\\"DQT: invalid table spec\\\\\\\");for(let e=0;e<64;e++){o[t[e]]=r()}}this.quantizationTables[15&s]=o}break}case 65472:case 65473:case 65474:{r();const t={extended:65473===a,progressive:65474===a,precision:e[n++],scanLines:r(),samplesPerLine:r(),components:{},componentsOrder:[]},s=e[n++];let c;for(let r=0;r<s;r++){c=e[n];const r=e[n+1]>>4,s=15&e[n+1],o=e[n+2];t.componentsOrder.push(c),t.components[c]={h:r,v:s,quantizationIdx:o},n+=3}o(t),this.frames.push(t);break}case 65476:{const t=r();for(let r=2;r<t;){const t=e[n++],s=new Uint8Array(16);let o=0;for(let r=0;r<16;r++,n++)s[r]=e[n],o+=s[r];const a=new Uint8Array(o);for(let r=0;r<o;r++,n++)a[r]=e[n];r+=17+o,t>>4==0?this.huffmanTablesDC[15&t]=u(s,a):this.huffmanTablesAC[15&t]=u(s,a)}break}case 65501:r(),this.resetInterval=r();break;case 65498:{r();const t=e[n++],s=[],o=this.frames[0];for(let r=0;r<t;r++){const t=o.components[e[n++]],r=e[n++];t.huffmanTableDC=this.huffmanTablesDC[r>>4],t.huffmanTableAC=this.huffmanTablesAC[15&r],s.push(t)}const a=e[n++],c=e[n++],i=e[n++],l=h(e,n,o,s,this.resetInterval,a,c,i>>4,15&i);n+=l;break}case 65535:255!==e[n]&&n--;break;default:if(255===e[n-3]&&e[n-2]>=192&&e[n-2]<=254){n-=3;break}throw new Error(`unknown JPEG marker ${a.toString(16)}`)}a=r()}}getResult(){const{frames:e}=this;if(0===this.frames.length)throw new Error(\\\\\\\"no frames were decoded\\\\\\\");this.frames.length>1&&console.warn(\\\\\\\"more than one frame is not supported\\\\\\\");for(let l=0;l<this.frames.length;l++){const e=this.frames[l].components;for(const n of Object.keys(e))e[n].quantizationTable=this.quantizationTables[e[n].quantizationIdx],delete e[n].quantizationIdx}const n=e[0],{components:t,componentsOrder:r}=n,s=[],o=n.samplesPerLine,a=n.scanLines;for(let l=0;l<r.length;l++){const e=t[r[l]];s.push({lines:m(n,e),scaleX:e.h/n.maxH,scaleY:e.v/n.maxV})}const c=new Uint8Array(o*a*s.length);let i=0;for(let l=0;l<a;++l)for(let e=0;e<o;++e)for(let n=0;n<s.length;++n){const t=s[n];c[i]=t.lines[0|l*t.scaleY][0|e*t.scaleX],++i}return c}}class b extends e.default{constructor(e){super(),this.reader=new d,e.JPEGTables&&this.reader.parse(e.JPEGTables)}decodeBlock(e){return this.reader.resetFrames(),this.reader.parse(new Uint8Array(e)),this.reader.getResult().buffer}}exports.default=b;\\\\n},{\\\\\\\"./basedecoder\\\\\\\":\\\\\\\"FJDe\\\\\\\"}],\\\\\\\"JAiC\\\\\\\":[function(require,module,exports) {\\\\n\\\\\\\"use strict\\\\\\\";Object.defineProperty(exports,\\\\\\\"__esModule\\\\\\\",{value:!0}),exports.default=void 0;var e=require(\\\\\\\"pako/lib/inflate\\\\\\\"),r=t(require(\\\\\\\"./basedecoder\\\\\\\"));function t(e){return e&&e.__esModule?e:{default:e}}class u extends r.default{decodeBlock(r){return(0,e.inflate)(new Uint8Array(r)).buffer}}exports.default=u;\\\\n},{\\\\\\\"./basedecoder\\\\\\\":\\\\\\\"FJDe\\\\\\\"}],\\\\\\\"OcPz\\\\\\\":[function(require,module,exports) {\\\\n\\\\\\\"use strict\\\\\\\";Object.defineProperty(exports,\\\\\\\"__esModule\\\\\\\",{value:!0}),exports.default=void 0;var e=t(require(\\\\\\\"./basedecoder\\\\\\\"));function t(e){return e&&e.__esModule?e:{default:e}}class r extends e.default{decodeBlock(e){const t=new DataView(e),r=[];for(let o=0;o<e.byteLength;++o){let e=t.getInt8(o);if(e<0){const s=t.getUint8(o+1);e=-e;for(let t=0;t<=e;++t)r.push(s);o+=1}else{for(let s=0;s<=e;++s)r.push(t.getUint8(o+s+1));o+=e+1}}return new Uint8Array(r).buffer}}exports.default=r;\\\\n},{\\\\\\\"./basedecoder\\\\\\\":\\\\\\\"FJDe\\\\\\\"}],\\\\\\\"FGCZ\\\\\\\":[function(require,module,exports) {\\\\n\\\\\\\"use strict\\\\\\\";Object.defineProperty(exports,\\\\\\\"__esModule\\\\\\\",{value:!0}),exports.getDecoder=u;var e=o(require(\\\\\\\"./raw\\\\\\\")),r=o(require(\\\\\\\"./lzw\\\\\\\")),t=o(require(\\\\\\\"./jpeg\\\\\\\")),n=o(require(\\\\\\\"./deflate\\\\\\\")),s=o(require(\\\\\\\"./packbits\\\\\\\"));function o(e){return e&&e.__esModule?e:{default:e}}function u(o){switch(o.Compression){case void 0:case 1:return new e.default;case 5:return new r.default;case 6:throw new Error(\\\\\\\"old style JPEG compression is not supported.\\\\\\\");case 7:return new t.default(o);case 8:case 32946:return new n.default;case 32773:return new s.default;default:throw new Error(`Unknown compression method identifier: ${o.Compression}`)}}\\\\n},{\\\\\\\"./raw\\\\\\\":\\\\\\\"V9bQ\\\\\\\",\\\\\\\"./lzw\\\\\\\":\\\\\\\"tcId\\\\\\\",\\\\\\\"./jpeg\\\\\\\":\\\\\\\"J7kk\\\\\\\",\\\\\\\"./deflate\\\\\\\":\\\\\\\"JAiC\\\\\\\",\\\\\\\"./packbits\\\\\\\":\\\\\\\"OcPz\\\\\\\"}],\\\\\\\"OQju\\\\\\\":[function(require,module,exports) {\\\\n\\\\\\\"use strict\\\\\\\";function e(e,t,r,n=1){return new(Object.getPrototypeOf(e).constructor)(t*r*n)}function t(t,r,n,o,a){const s=r/o,c=n/a;return t.map(t=>{const l=e(t,o,a);for(let e=0;e<a;++e){const a=Math.min(Math.round(c*e),n-1);for(let n=0;n<o;++n){const c=Math.min(Math.round(s*n),r-1),i=t[a*r+c];l[e*o+n]=i}}return l})}function r(e,t,r){return(1-r)*e+r*t}function n(t,n,o,a,s){const c=n/a,l=o/s;return t.map(t=>{const i=e(t,a,s);for(let e=0;e<s;++e){const s=l*e,u=Math.floor(s),f=Math.min(Math.ceil(s),o-1);for(let o=0;o<a;++o){const l=c*o,h=l%1,p=Math.floor(l),M=Math.min(Math.ceil(l),n-1),m=t[u*n+p],d=t[u*n+M],w=t[f*n+p],x=t[f*n+M],b=r(r(m,d,h),r(w,x,h),s%1);i[e*a+o]=b}}return i})}function o(e,r,o,a,s,c=\\\\\\\"nearest\\\\\\\"){switch(c.toLowerCase()){case\\\\\\\"nearest\\\\\\\":return t(e,r,o,a,s);case\\\\\\\"bilinear\\\\\\\":case\\\\\\\"linear\\\\\\\":return n(e,r,o,a,s);default:throw new Error(`Unsupported resampling method: '${c}'`)}}function a(t,r,n,o,a,s){const c=r/o,l=n/a,i=e(t,o,a,s);for(let e=0;e<a;++e){const a=Math.min(Math.round(l*e),n-1);for(let n=0;n<o;++n){const l=Math.min(Math.round(c*n),r-1);for(let c=0;c<s;++c){const u=t[a*r*s+l*s+c];i[e*o*s+n*s+c]=u}}}return i}function s(t,n,o,a,s,c){const l=n/a,i=o/s,u=e(t,a,s,c);for(let e=0;e<s;++e){const s=i*e,f=Math.floor(s),h=Math.min(Math.ceil(s),o-1);for(let o=0;o<a;++o){const i=l*o,p=i%1,M=Math.floor(i),m=Math.min(Math.ceil(i),n-1);for(let l=0;l<c;++l){const i=t[f*n*c+M*c+l],d=t[f*n*c+m*c+l],w=t[h*n*c+M*c+l],x=t[h*n*c+m*c+l],b=r(r(i,d,p),r(w,x,p),s%1);u[e*a*c+o*c+l]=b}}}return u}function c(e,t,r,n,o,c,l=\\\\\\\"nearest\\\\\\\"){switch(l.toLowerCase()){case\\\\\\\"nearest\\\\\\\":return a(e,t,r,n,o,c);case\\\\\\\"bilinear\\\\\\\":case\\\\\\\"linear\\\\\\\":return s(e,t,r,n,o,c);default:throw new Error(`Unsupported resampling method: '${l}'`)}}Object.defineProperty(exports,\\\\\\\"__esModule\\\\\\\",{value:!0}),exports.resampleNearest=t,exports.resampleBilinear=n,exports.resample=o,exports.resampleNearestInterleaved=a,exports.resampleBilinearInterleaved=s,exports.resampleInterleaved=c;\\\\n},{}],\\\\\\\"eOWo\\\\\\\":[function(require,module,exports) {\\\\n\\\\\\\"use strict\\\\\\\";Object.defineProperty(exports,\\\\\\\"__esModule\\\\\\\",{value:!0}),exports.default=void 0;var t=a(require(\\\\\\\"txml\\\\\\\")),e=require(\\\\\\\"./globals\\\\\\\"),r=require(\\\\\\\"./rgb\\\\\\\"),i=require(\\\\\\\"./compression\\\\\\\"),o=require(\\\\\\\"./resample\\\\\\\");function a(t){return t&&t.__esModule?t:{default:t}}function s(t,e,r){let i=0;for(let o=e;o<r;++o)i+=t[o];return i}function n(t,e,r){switch(t){case 1:switch(e){case 8:return new Uint8Array(r);case 16:return new Uint16Array(r);case 32:return new Uint32Array(r)}break;case 2:switch(e){case 8:return new Int8Array(r);case 16:return new Int16Array(r);case 32:return new Int32Array(r)}break;case 3:switch(e){case 32:return new Float32Array(r);case 64:return new Float64Array(r)}}throw Error(\\\\\\\"Unsupported data format/bitsPerSample\\\\\\\")}class l{constructor(t,e,r,i,o,a){this.fileDirectory=t,this.geoKeys=e,this.dataView=r,this.littleEndian=i,this.tiles=o?{}:null,this.isTiled=!t.StripOffsets;const s=t.PlanarConfiguration;if(this.planarConfiguration=void 0===s?1:s,1!==this.planarConfiguration&&2!==this.planarConfiguration)throw new Error(\\\\\\\"Invalid planar configuration.\\\\\\\");this.source=a}getFileDirectory(){return this.fileDirectory}getGeoKeys(){return this.geoKeys}getWidth(){return this.fileDirectory.ImageWidth}getHeight(){return this.fileDirectory.ImageLength}getSamplesPerPixel(){return this.fileDirectory.SamplesPerPixel}getTileWidth(){return this.isTiled?this.fileDirectory.TileWidth:this.getWidth()}getTileHeight(){return this.isTiled?this.fileDirectory.TileLength:void 0!==this.fileDirectory.RowsPerStrip?Math.min(this.fileDirectory.RowsPerStrip,this.getHeight()):this.getHeight()}getBytesPerPixel(){let t=0;for(let e=0;e<this.fileDirectory.BitsPerSample.length;++e){const r=this.fileDirectory.BitsPerSample[e];if(r%8!=0)throw new Error(`Sample bit-width of ${r} is not supported.`);if(r!==this.fileDirectory.BitsPerSample[0])throw new Error(\\\\\\\"Differing size of samples in a pixel are not supported.\\\\\\\");t+=r}return t/8}getSampleByteSize(t){if(t>=this.fileDirectory.BitsPerSample.length)throw new RangeError(`Sample index ${t} is out of range.`);const e=this.fileDirectory.BitsPerSample[t];if(e%8!=0)throw new Error(`Sample bit-width of ${e} is not supported.`);return e/8}getReaderForSample(t){const e=this.fileDirectory.SampleFormat?this.fileDirectory.SampleFormat[t]:1,r=this.fileDirectory.BitsPerSample[t];switch(e){case 1:switch(r){case 8:return DataView.prototype.getUint8;case 16:return DataView.prototype.getUint16;case 32:return DataView.prototype.getUint32}break;case 2:switch(r){case 8:return DataView.prototype.getInt8;case 16:return DataView.prototype.getInt16;case 32:return DataView.prototype.getInt32}break;case 3:switch(r){case 32:return DataView.prototype.getFloat32;case 64:return DataView.prototype.getFloat64}}throw Error(\\\\\\\"Unsupported data format/bitsPerSample\\\\\\\")}getArrayForSample(t,e){return n(this.fileDirectory.SampleFormat?this.fileDirectory.SampleFormat[t]:1,this.fileDirectory.BitsPerSample[t],e)}async getTileOrStrip(t,e,r,i){const o=Math.ceil(this.getWidth()/this.getTileWidth()),a=Math.ceil(this.getHeight()/this.getTileHeight());let s;const{tiles:n}=this;let l,h;1===this.planarConfiguration?s=e*o+t:2===this.planarConfiguration&&(s=r*o*a+e*o+t),this.isTiled?(l=this.fileDirectory.TileOffsets[s],h=this.fileDirectory.TileByteCounts[s]):(l=this.fileDirectory.StripOffsets[s],h=this.fileDirectory.StripByteCounts[s]);const c=await this.source.fetch(l,h);let p;return null===n?p=i.decode(this.fileDirectory,c):n[s]||(p=i.decode(this.fileDirectory,c),n[s]=p),{x:t,y:e,sample:r,data:await p}}async _readRaster(t,e,r,i,a,n,l,h){const c=this.getTileWidth(),p=this.getTileHeight(),f=Math.max(Math.floor(t[0]/c),0),g=Math.min(Math.ceil(t[2]/c),Math.ceil(this.getWidth()/this.getTileWidth())),u=Math.max(Math.floor(t[1]/p),0),m=Math.min(Math.ceil(t[3]/p),Math.ceil(this.getHeight()/this.getTileHeight())),d=t[2]-t[0];let y=this.getBytesPerPixel();const w=[],D=[];for(let o=0;o<e.length;++o)1===this.planarConfiguration?w.push(s(this.fileDirectory.BitsPerSample,0,e[o])/8):w.push(0),D.push(this.getReaderForSample(e[o]));const M=[],{littleEndian:S}=this;for(let o=u;o<m;++o)for(let s=f;s<g;++s)for(let n=0;n<e.length;++n){const l=n,h=e[n];2===this.planarConfiguration&&(y=this.getSampleByteSize(h));const f=this.getTileOrStrip(s,o,h,a);M.push(f),f.then(o=>{const a=o.data,s=new DataView(a),n=o.y*p,h=o.x*c,f=(o.y+1)*p,g=(o.x+1)*c,u=D[l],m=Math.min(p,p-(f-t[3])),M=Math.min(c,c-(g-t[2]));for(let p=Math.max(0,t[1]-n);p<m;++p)for(let o=Math.max(0,t[0]-h);o<M;++o){const a=(p*c+o)*y,f=u.call(s,a+w[l],S);let g;i?(g=(p+n-t[1])*d*e.length+(o+h-t[0])*e.length+l,r[g]=f):(g=(p+n-t[1])*d+o+h-t[0],r[l][g]=f)}})}if(await Promise.all(M),n&&t[2]-t[0]!==n||l&&t[3]-t[1]!==l){let a;return(a=i?(0,o.resampleInterleaved)(r,t[2]-t[0],t[3]-t[1],n,l,e.length,h):(0,o.resample)(r,t[2]-t[0],t[3]-t[1],n,l,h)).width=n,a.height=l,a}return r.width=n||t[2]-t[0],r.height=l||t[3]-t[1],r}async readRasters({window:t,samples:e=[],interleave:r,pool:o=null,width:a,height:s,resampleMethod:l,fillValue:h}={}){const c=t||[0,0,this.getWidth(),this.getHeight()];if(c[0]>c[2]||c[1]>c[3])throw new Error(\\\\\\\"Invalid subsets\\\\\\\");const p=(c[2]-c[0])*(c[3]-c[1]);if(e&&e.length){for(let i=0;i<e.length;++i)if(e[i]>=this.fileDirectory.SamplesPerPixel)return Promise.reject(new RangeError(`Invalid sample index '${e[i]}'.`))}else for(let i=0;i<this.fileDirectory.SamplesPerPixel;++i)e.push(i);let f;if(r){f=n(this.fileDirectory.SampleFormat?Math.max.apply(null,this.fileDirectory.SampleFormat):1,Math.max.apply(null,this.fileDirectory.BitsPerSample),p*e.length),h&&f.fill(h)}else{f=[];for(let t=0;t<e.length;++t){const r=this.getArrayForSample(e[t],p);Array.isArray(h)&&t<h.length?r.fill(h[t]):h&&!Array.isArray(h)&&r.fill(h),f.push(r)}}const g=o||(0,i.getDecoder)(this.fileDirectory);return await this._readRaster(c,e,f,r,g,a,s,l)}async readRGB({window:t,pool:i=null,width:o,height:a,resampleMethod:s,enableAlpha:n=!1}={}){const l=t||[0,0,this.getWidth(),this.getHeight()];if(l[0]>l[2]||l[1]>l[3])throw new Error(\\\\\\\"Invalid subsets\\\\\\\");const h=this.fileDirectory.PhotometricInterpretation;if(h===e.photometricInterpretations.RGB){let r=[0,1,2];if(this.fileDirectory.ExtraSamples!==e.ExtraSamplesValues.Unspecified&&n){r=[];for(let t=0;t<this.fileDirectory.BitsPerSample.length;t+=1)r.push(t)}return this.readRasters({window:t,interleave:!0,samples:r,pool:i,width:o,height:a})}let c;switch(h){case e.photometricInterpretations.WhiteIsZero:case e.photometricInterpretations.BlackIsZero:case e.photometricInterpretations.Palette:c=[0];break;case e.photometricInterpretations.CMYK:c=[0,1,2,3];break;case e.photometricInterpretations.YCbCr:case e.photometricInterpretations.CIELab:c=[0,1,2];break;default:throw new Error(\\\\\\\"Invalid or unsupported photometric interpretation.\\\\\\\")}const p={window:l,interleave:!0,samples:c,pool:i,width:o,height:a,resampleMethod:s},{fileDirectory:f}=this,g=await this.readRasters(p),u=2**this.fileDirectory.BitsPerSample[0];let m;switch(h){case e.photometricInterpretations.WhiteIsZero:m=(0,r.fromWhiteIsZero)(g,u);break;case e.photometricInterpretations.BlackIsZero:m=(0,r.fromBlackIsZero)(g,u);break;case e.photometricInterpretations.Palette:m=(0,r.fromPalette)(g,f.ColorMap);break;case e.photometricInterpretations.CMYK:m=(0,r.fromCMYK)(g);break;case e.photometricInterpretations.YCbCr:m=(0,r.fromYCbCr)(g);break;case e.photometricInterpretations.CIELab:m=(0,r.fromCIELab)(g);break;default:throw new Error(\\\\\\\"Unsupported photometric interpretation.\\\\\\\")}return m.width=g.width,m.height=g.height,m}getTiePoints(){if(!this.fileDirectory.ModelTiepoint)return[];const t=[];for(let e=0;e<this.fileDirectory.ModelTiepoint.length;e+=6)t.push({i:this.fileDirectory.ModelTiepoint[e],j:this.fileDirectory.ModelTiepoint[e+1],k:this.fileDirectory.ModelTiepoint[e+2],x:this.fileDirectory.ModelTiepoint[e+3],y:this.fileDirectory.ModelTiepoint[e+4],z:this.fileDirectory.ModelTiepoint[e+5]});return t}getGDALMetadata(e=null){const r={};if(!this.fileDirectory.GDAL_METADATA)return null;const i=this.fileDirectory.GDAL_METADATA,o=(0,t.default)(i.substring(0,i.length-1));if(!o[0].tagName)throw new Error(\\\\\\\"Failed to parse GDAL metadata XML.\\\\\\\");const a=o[0];if(\\\\\\\"GDALMetadata\\\\\\\"!==a.tagName)throw new Error(\\\\\\\"Unexpected GDAL metadata XML tag.\\\\\\\");let s=a.children.filter(t=>\\\\\\\"Item\\\\\\\"===t.tagName);e&&(s=s.filter(t=>Number(t.attributes.sample)===e));for(let t=0;t<s.length;++t){const e=s[t];r[e.attributes.name]=e.children[0]}return r}getGDALNoData(){if(!this.fileDirectory.GDAL_NODATA)return null;const t=this.fileDirectory.GDAL_NODATA;return Number(t.substring(0,t.length-1))}getOrigin(){const t=this.fileDirectory.ModelTiepoint,e=this.fileDirectory.ModelTransformation;if(t&&6===t.length)return[t[3],t[4],t[5]];if(e)return[e[3],e[7],e[11]];throw new Error(\\\\\\\"The image does not have an affine transformation.\\\\\\\")}getResolution(t=null){const e=this.fileDirectory.ModelPixelScale,r=this.fileDirectory.ModelTransformation;if(e)return[e[0],-e[1],e[2]];if(r)return[r[0],r[5],r[10]];if(t){const[e,r,i]=t.getResolution();return[e*t.getWidth()/this.getWidth(),r*t.getHeight()/this.getHeight(),i*t.getWidth()/this.getWidth()]}throw new Error(\\\\\\\"The image does not have an affine transformation.\\\\\\\")}pixelIsArea(){return 1===this.geoKeys.GTRasterTypeGeoKey}getBoundingBox(){const t=this.getOrigin(),e=this.getResolution(),r=t[0],i=t[1],o=r+e[0]*this.getWidth(),a=i+e[1]*this.getHeight();return[Math.min(r,o),Math.min(i,a),Math.max(r,o),Math.max(i,a)]}}var h=l;exports.default=h;\\\\n},{\\\\\\\"./globals\\\\\\\":\\\\\\\"j27V\\\\\\\",\\\\\\\"./rgb\\\\\\\":\\\\\\\"fpBl\\\\\\\",\\\\\\\"./compression\\\\\\\":\\\\\\\"FGCZ\\\\\\\",\\\\\\\"./resample\\\\\\\":\\\\\\\"OQju\\\\\\\"}],\\\\\\\"dqpX\\\\\\\":[function(require,module,exports) {\\\\n\\\\\\\"use strict\\\\\\\";Object.defineProperty(exports,\\\\\\\"__esModule\\\\\\\",{value:!0}),exports.default=void 0;class t{constructor(t){this._dataView=new DataView(t)}get buffer(){return this._dataView.buffer}getUint64(t,e){const i=this.getUint32(t,e),n=this.getUint32(t+4,e);return e?i<<32|n:n<<32|i}getInt64(t,e){let i,n;return e?(i=this.getInt32(t,e))<<32|(n=this.getUint32(t+4,e)):(i=this.getUint32(t,e),(n=this.getInt32(t+4,e))<<32|i)}getUint8(t,e){return this._dataView.getUint8(t,e)}getInt8(t,e){return this._dataView.getInt8(t,e)}getUint16(t,e){return this._dataView.getUint16(t,e)}getInt16(t,e){return this._dataView.getInt16(t,e)}getUint32(t,e){return this._dataView.getUint32(t,e)}getInt32(t,e){return this._dataView.getInt32(t,e)}getFloat32(t,e){return this._dataView.getFloat32(t,e)}getFloat64(t,e){return this._dataView.getFloat64(t,e)}}exports.default=t;\\\\n},{}],\\\\\\\"dGLV\\\\\\\":[function(require,module,exports) {\\\\n\\\\\\\"use strict\\\\\\\";Object.defineProperty(exports,\\\\\\\"__esModule\\\\\\\",{value:!0}),exports.default=void 0;class t{constructor(t,e,i,s){this._dataView=new DataView(t),this._sliceOffset=e,this._littleEndian=i,this._bigTiff=s}get sliceOffset(){return this._sliceOffset}get sliceTop(){return this._sliceOffset+this.buffer.byteLength}get littleEndian(){return this._littleEndian}get bigTiff(){return this._bigTiff}get buffer(){return this._dataView.buffer}covers(t,e){return this.sliceOffset<=t&&this.sliceTop>=t+e}readUint8(t){return this._dataView.getUint8(t-this._sliceOffset,this._littleEndian)}readInt8(t){return this._dataView.getInt8(t-this._sliceOffset,this._littleEndian)}readUint16(t){return this._dataView.getUint16(t-this._sliceOffset,this._littleEndian)}readInt16(t){return this._dataView.getInt16(t-this._sliceOffset,this._littleEndian)}readUint32(t){return this._dataView.getUint32(t-this._sliceOffset,this._littleEndian)}readInt32(t){return this._dataView.getInt32(t-this._sliceOffset,this._littleEndian)}readFloat32(t){return this._dataView.getFloat32(t-this._sliceOffset,this._littleEndian)}readFloat64(t){return this._dataView.getFloat64(t-this._sliceOffset,this._littleEndian)}readUint64(t){const e=this.readUint32(t),i=this.readUint32(t+4);let s;if(this._littleEndian){if(s=e+2**32*i,!Number.isSafeInteger(s))throw new Error(`${s} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return s}if(s=2**32*e+i,!Number.isSafeInteger(s))throw new Error(`${s} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return s}readInt64(t){let e,i;if(this._littleEndian){if(e=this.readInt32(t),i=this.readUint32(t+4),combined=e+2**32*i,!Number.isSafeInteger(combined))throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return combined}if(e=this.readUint32(t-this._sliceOffset),i=this.readInt32(t-this._sliceOffset+4),combined=2**32*e+i,!Number.isSafeInteger(combined))throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return combined}readOffset(t){return this._bigTiff?this.readUint64(t):this.readUint32(t)}}exports.default=t;\\\\n},{}],\\\\\\\"dHPO\\\\\\\":[function(require,module,exports) {\\\\n\\\\\\\"use strict\\\\\\\";Object.defineProperty(exports,\\\\\\\"__esModule\\\\\\\",{value:!0}),exports.default=void 0,require(\\\\\\\"threads/register\\\\\\\");var e=require(\\\\\\\"threads\\\\\\\");const r=\\\\\\\"undefined\\\\\\\"!=typeof navigator?navigator.hardwareConcurrency:null;class t{constructor(t=r){const o=new Worker(\\\\\\\"/decoder.worker.7cb947d7.js\\\\\\\");this.pool=(0,e.Pool)(()=>(0,e.spawn)(o),t)}async decode(e,r){return new Promise((t,o)=>{this.pool.queue(async s=>{try{const n=await s(e,r);t(n)}catch(a){o(a)}})})}destroy(){this.pool.terminate(!0)}}var o=t;exports.default=o;\\\\n},{\\\\\\\"./decoder.worker.js\\\\\\\":[[\\\\\\\"decoder.worker.7cb947d7.js\\\\\\\",\\\\\\\"LHx9\\\\\\\"],\\\\\\\"decoder.worker.7cb947d7.js.map\\\\\\\",\\\\\\\"LHx9\\\\\\\"]}],\\\\\\\"cUx7\\\\\\\":[function(require,module,exports) {\\\\n\\\\\\\"use strict\\\\\\\";Object.defineProperty(exports,\\\\\\\"__esModule\\\\\\\",{value:!0}),exports.makeFetchSource=f,exports.makeXHRSource=l,exports.makeHttpSource=h,exports.makeRemoteSource=b,exports.makeBufferSource=d,exports.makeFileSource=p,exports.makeFileReaderSource=y;var e=require(\\\\\\\"buffer\\\\\\\"),t=require(\\\\\\\"fs\\\\\\\"),s=n(require(\\\\\\\"http\\\\\\\")),r=n(require(\\\\\\\"https\\\\\\\")),o=n(require(\\\\\\\"url\\\\\\\"));function n(e){return e&&e.__esModule?e:{default:e}}function a(e,t,s){const r=t+s,o=new ArrayBuffer(s),n=new Uint8Array(o);for(const a of e){const e=a.offset-t,s=a.top-r;let o,i=0,c=0;e<0?i=-e:e>0&&(c=e),s<0?o=a.length-i:s>0&&(o=r-a.offset-i);const u=new Uint8Array(a.data,i,o);n.set(u,c)}return o}function i(e){if(0===e.length)return[];const t=[];let s=[];t.push(s);for(let r=0;r<e.length;++r)0===r||e[r]===e[r-1]+1?s.push(e[r]):(s=[e[r]],t.push(s));return t}async function c(e){return new Promise(t=>setTimeout(t,e))}class u{constructor(e,{blockSize:t=65536}={}){this.retrievalFunction=e,this.blockSize=t,this.blockRequests=new Map,this.blocks=new Map,this.blockIdsAwaitingRequest=null}async fetch(e,t,s=!1){const r=e+t,o=[],n=[],u=[];for(let a=Math.floor(e/this.blockSize)*this.blockSize;a<r;a+=this.blockSize){const e=Math.floor(a/this.blockSize);this.blocks.has(e)||this.blockRequests.has(e)||n.push(e),this.blockRequests.has(e)&&u.push(this.blockRequests.get(e)),o.push(e)}if(this.blockIdsAwaitingRequest)for(let a=0;a<n.length;++a){const e=n[a];this.blockIdsAwaitingRequest.add(e)}else this.blockIdsAwaitingRequest=new Set(n);if(s||await c(),this.blockIdsAwaitingRequest){const e=i(Array.from(this.blockIdsAwaitingRequest).sort());for(const t of e){const e=this.requestData(t[0]*this.blockSize,t.length*this.blockSize);for(let s=0;s<t.length;++s){const r=t[s];this.blockRequests.set(r,(async()=>{const t=await e,o=s*this.blockSize,n=Math.min(o+this.blockSize,t.data.byteLength),a=t.data.slice(o,n);this.blockRequests.delete(r),this.blocks.set(r,{data:a,offset:t.offset+o,length:a.byteLength,top:t.offset+n})})())}}this.blockIdsAwaitingRequest=null}const f=[];for(const a of n)this.blockRequests.has(a)&&f.push(this.blockRequests.get(a));return await Promise.all(f),await Promise.all(u),a(o.map(e=>this.blocks.get(e)),e,t)}async requestData(e,t){const s=await this.retrievalFunction(e,t);return s.length?s.length!==s.data.byteLength&&(s.data=s.data.slice(0,s.length)):s.length=s.data.byteLength,s.top=s.offset+s.length,s}}function f(e,{headers:t={},blockSize:s}={}){return new u(async(s,r)=>{const o=await fetch(e,{headers:{...t,Range:`bytes=${s}-${s+r-1}`}});if(o.ok){if(206===o.status){return{data:o.arrayBuffer?await o.arrayBuffer():(await o.buffer()).buffer,offset:s,length:r}}{const e=o.arrayBuffer?await o.arrayBuffer():(await o.buffer()).buffer;return{data:e,offset:0,length:e.byteLength}}}throw new Error(\\\\\\\"Error fetching data.\\\\\\\")},{blockSize:s})}function l(e,{headers:t={},blockSize:s}={}){return new u(async(s,r)=>new Promise((o,n)=>{const a=new XMLHttpRequest;a.open(\\\\\\\"GET\\\\\\\",e),a.responseType=\\\\\\\"arraybuffer\\\\\\\";const i={...t,Range:`bytes=${s}-${s+r-1}`};for(const[e,t]of Object.entries(i))a.setRequestHeader(e,t);a.onload=(()=>{const e=a.response;206===a.status?o({data:e,offset:s,length:r}):o({data:e,offset:0,length:e.byteLength})}),a.onerror=n,a.send()}),{blockSize:s})}function h(t,{headers:n={},blockSize:a}={}){return new u(async(a,i)=>new Promise((c,u)=>{const f=o.default.parse(t);(\\\\\\\"http:\\\\\\\"===f.protocol?s.default:r.default).get({...f,headers:{...n,Range:`bytes=${a}-${a+i-1}`}},t=>{const s=[];t.on(\\\\\\\"data\\\\\\\",e=>{s.push(e)}),t.on(\\\\\\\"end\\\\\\\",()=>{const t=e.Buffer.concat(s).buffer;c({data:t,offset:a,length:t.byteLength})})}).on(\\\\\\\"error\\\\\\\",u)}),{blockSize:a})}function b(e,t){const{forceXHR:r}=t;if(\\\\\\\"function\\\\\\\"==typeof fetch&&!r)return f(e,t);if(\\\\\\\"undefined\\\\\\\"!=typeof XMLHttpRequest)return l(e,t);if(s.default.get)return h(e,t);throw new Error(\\\\\\\"No remote source available\\\\\\\")}function d(e){return{fetch:async(t,s)=>e.slice(t,t+s)}}function k(e){return new Promise((s,r)=>{(0,t.close)(e,e=>{e?r(e):s()})})}function w(e,s,r){return new Promise((o,n)=>{(0,t.open)(e,s,r,(e,t)=>{e?n(e):o(t)})})}function g(...e){return new Promise((s,r)=>{(0,t.read)(...e,(e,t,o)=>{e?r(e):s({bytesRead:t,buffer:o})})})}function p(t){const s=w(t,\\\\\\\"r\\\\\\\");return{async fetch(t,r){const o=await s,{buffer:n}=await g(o,e.Buffer.alloc(r),0,r,t);return n.buffer},async close(){const e=await s;return await k(e)}}}function y(e){return{fetch:async(t,s)=>new Promise((r,o)=>{const n=e.slice(t,t+s),a=new FileReader;a.onload=(e=>r(e.target.result)),a.onerror=o,a.readAsArrayBuffer(n)})}}\\\\n},{}],\\\\\\\"FOZT\\\\\\\":[function(require,module,exports) {\\\\n\\\\\\\"use strict\\\\\\\";function t(t,n){for(const r in n)n.hasOwnProperty(r)&&(t[r]=n[r])}function n(t,n){const r=[],e=t.length;for(let o=0;o<e;o+=n){const e=[];for(let r=o;r<o+n;r++)e.push(t[r]);r.push(e)}return r}function r(t,n){if(t.length<n.length)return!1;return t.substr(t.length-n.length)===n}function e(t,n){const{length:r}=t;for(let e=0;e<r;e++)n(t[e],e)}function o(t){const n={};for(const r in t)if(t.hasOwnProperty(r)){n[t[r]]=r}return n}function s(t){const n=[];for(let r=0;r<t;r++)n.push(r);return n}function u(t,n){const r=[];for(let e=0;e<t;e++)r.push(n(e));return r}function c(t){const n=[],{length:r}=t;for(let e=0;e<r;e++)n.push(t[e]);return n}function f(t){return t.length?c(t).map(f):t}Object.defineProperty(exports,\\\\\\\"__esModule\\\\\\\",{value:!0}),exports.assign=t,exports.chunk=n,exports.endsWith=r,exports.forEach=e,exports.invert=o,exports.range=s,exports.times=u,exports.toArray=c,exports.toArrayRecursively=f;\\\\n},{}],\\\\\\\"BGyE\\\\\\\":[function(require,module,exports) {\\\\n\\\\\\\"use strict\\\\\\\";Object.defineProperty(exports,\\\\\\\"__esModule\\\\\\\",{value:!0}),exports.writeGeotiff=p;var e=require(\\\\\\\"./globals\\\\\\\"),t=require(\\\\\\\"./utils\\\\\\\");const r=(0,t.invert)(e.fieldTagNames),o=(0,t.invert)(e.geoKeyNames),i={};(0,t.assign)(i,r),(0,t.assign)(i,o);const n=(0,t.invert)(e.fieldTypeNames),s=1e3,a={nextZero:(e,t)=>{let r=t;for(;0!==e[r];)r++;return r},readUshort:(e,t)=>e[t]<<8|e[t+1],readShort:(e,t)=>{const r=a.ui8;return r[0]=e[t+1],r[1]=e[t+0],a.i16[0]},readInt:(e,t)=>{const r=a.ui8;return r[0]=e[t+3],r[1]=e[t+2],r[2]=e[t+1],r[3]=e[t+0],a.i32[0]},readUint:(e,t)=>{const r=a.ui8;return r[0]=e[t+3],r[1]=e[t+2],r[2]=e[t+1],r[3]=e[t+0],a.ui32[0]},readASCII:(e,t,r)=>r.map(r=>String.fromCharCode(e[t+r])).join(\\\\\\\"\\\\\\\"),readFloat:(e,r)=>{const o=a.ui8;return(0,t.times)(4,t=>{o[t]=e[r+3-t]}),a.fl32[0]},readDouble:(e,r)=>{const o=a.ui8;return(0,t.times)(8,t=>{o[t]=e[r+7-t]}),a.fl64[0]},writeUshort:(e,t,r)=>{e[t]=r>>8&255,e[t+1]=255&r},writeUint:(e,t,r)=>{e[t]=r>>24&255,e[t+1]=r>>16&255,e[t+2]=r>>8&255,e[t+3]=r>>0&255},writeASCII:(e,r,o)=>{(0,t.times)(o.length,t=>{e[r+t]=o.charCodeAt(t)})},ui8:new Uint8Array(8)};a.fl64=new Float64Array(a.ui8.buffer),a.writeDouble=((e,r,o)=>{a.fl64[0]=o,(0,t.times)(8,t=>{e[r+t]=a.ui8[7-t]})});const l=(r,o,i,s)=>{let a=i;const l=Object.keys(s).filter(e=>null!=e&&\\\\\\\"undefined\\\\\\\"!==e);r.writeUshort(o,a,l.length);let f=(a+=2)+12*l.length+4;for(const u of l){let i=null;\\\\\\\"number\\\\\\\"==typeof u?i=u:\\\\\\\"string\\\\\\\"==typeof u&&(i=parseInt(u,10));const l=e.fieldTagTypes[i],c=n[l];if(null==l||void 0===l||void 0===l)throw new Error(`unknown type of tag: ${i}`);let h=s[u];if(void 0===h)throw new Error(`failed to get value for key ${u}`);\\\\\\\"ASCII\\\\\\\"===l&&\\\\\\\"string\\\\\\\"==typeof h&&!1===(0,t.endsWith)(h,\\\\\\\"\\\\\\\\0\\\\\\\")&&(h+=\\\\\\\"\\\\\\\\0\\\\\\\");const m=h.length;r.writeUshort(o,a,i),a+=2,r.writeUshort(o,a,c),a+=2,r.writeUint(o,a,m);let p=[-1,1,1,2,4,8,0,0,0,0,0,0,8][c]*m,y=a+=4;p>4&&(r.writeUint(o,a,f),y=f),\\\\\\\"ASCII\\\\\\\"===l?r.writeASCII(o,y,h):\\\\\\\"SHORT\\\\\\\"===l?(0,t.times)(m,e=>{r.writeUshort(o,y+2*e,h[e])}):\\\\\\\"LONG\\\\\\\"===l?(0,t.times)(m,e=>{r.writeUint(o,y+4*e,h[e])}):\\\\\\\"RATIONAL\\\\\\\"===l?(0,t.times)(m,e=>{r.writeUint(o,y+8*e,Math.round(1e4*h[e])),r.writeUint(o,y+8*e+4,1e4)}):\\\\\\\"DOUBLE\\\\\\\"===l&&(0,t.times)(m,e=>{r.writeDouble(o,y+8*e,h[e])}),p>4&&(f+=p+=1&p),a+=4}return[a,f]},f=e=>{const t=new Uint8Array(1e3);let r=4;const o=a;t[0]=77,t[1]=77,t[3]=42;let i=8;if(o.writeUint(t,r,i),r+=4,e.forEach((r,n)=>{const s=l(o,t,i,r);i=s[1],n<e.length-1&&o.writeUint(t,s[0],i)}),t.slice)return t.slice(0,i).buffer;const n=new Uint8Array(i);for(let s=0;s<i;s++)n[s]=t[s];return n.buffer},u=(e,r,o,i)=>{if(null==o)throw new Error(`you passed into encodeImage a width of type ${o}`);if(null==r)throw new Error(`you passed into encodeImage a width of type ${r}`);const n={256:[r],257:[o],273:[1e3],278:[o],305:\\\\\\\"geotiff.js\\\\\\\"};if(i)for(const t in i)i.hasOwnProperty(t)&&(n[t]=i[t]);const s=new Uint8Array(f([n])),a=new Uint8Array(e),l=n[277],u=new Uint8Array(1e3+r*o*l);return(0,t.times)(s.length,e=>{u[e]=s[e]}),(0,t.forEach)(a,(e,t)=>{u[1e3+t]=e}),u.buffer},c=e=>{const t={};for(const r in e)\\\\\\\"StripOffsets\\\\\\\"!==r&&(i[r]||console.error(r,\\\\\\\"not in name2code:\\\\\\\",Object.keys(i)),t[i[r]]=e[r]);return t},h=e=>Array.isArray(e)?e:[e],m=[[\\\\\\\"Compression\\\\\\\",1],[\\\\\\\"PlanarConfiguration\\\\\\\",1],[\\\\\\\"XPosition\\\\\\\",0],[\\\\\\\"YPosition\\\\\\\",0],[\\\\\\\"ResolutionUnit\\\\\\\",1],[\\\\\\\"ExtraSamples\\\\\\\",0],[\\\\\\\"GeoAsciiParams\\\\\\\",\\\\\\\"WGS 84\\\\\\\\0\\\\\\\"],[\\\\\\\"ModelTiepoint\\\\\\\",[0,0,0,-180,90,0]],[\\\\\\\"GTModelTypeGeoKey\\\\\\\",2],[\\\\\\\"GTRasterTypeGeoKey\\\\\\\",1],[\\\\\\\"GeographicTypeGeoKey\\\\\\\",4326],[\\\\\\\"GeogCitationGeoKey\\\\\\\",\\\\\\\"WGS 84\\\\\\\"]];function p(r,o){let n,s,a,l;\\\\\\\"number\\\\\\\"==typeof r[0]?(n=o.height||o.ImageLength,a=o.width||o.ImageWidth,s=r.length/(n*a),l=r):(s=r.length,n=r[0].length,a=r[0][0].length,l=[],(0,t.times)(n,e=>{(0,t.times)(a,o=>{(0,t.times)(s,t=>{l.push(r[t][e][o])})})})),o.ImageLength=n,delete o.height,o.ImageWidth=a,delete o.width,o.BitsPerSample||(o.BitsPerSample=(0,t.times)(s,()=>8)),m.forEach(e=>{const t=e[0];if(!o[t]){const r=e[1];o[t]=r}}),o.PhotometricInterpretation||(o.PhotometricInterpretation=3===o.BitsPerSample.length?2:1),o.SamplesPerPixel||(o.SamplesPerPixel=[s]),o.StripByteCounts||(o.StripByteCounts=[s*n*a]),o.ModelPixelScale||(o.ModelPixelScale=[360/a,180/n,0]),o.SampleFormat||(o.SampleFormat=(0,t.times)(s,()=>1));const f=Object.keys(o).filter(e=>(0,t.endsWith)(e,\\\\\\\"GeoKey\\\\\\\")).sort((e,t)=>i[e]-i[t]);if(!o.GeoKeyDirectory){const t=[1,1,0,f.length];f.forEach(r=>{const n=Number(i[r]);let s,a,l;t.push(n),\\\\\\\"SHORT\\\\\\\"===e.fieldTagTypes[n]?(s=1,a=0,l=o[r]):\\\\\\\"GeogCitationGeoKey\\\\\\\"===r?(s=o.GeoAsciiParams.length,a=Number(i.GeoAsciiParams),l=0):console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${r}`),t.push(a),t.push(s),t.push(l)}),o.GeoKeyDirectory=t}for(const e in f)f.hasOwnProperty(e)&&delete o[e];[\\\\\\\"Compression\\\\\\\",\\\\\\\"ExtraSamples\\\\\\\",\\\\\\\"GeographicTypeGeoKey\\\\\\\",\\\\\\\"GTModelTypeGeoKey\\\\\\\",\\\\\\\"GTRasterTypeGeoKey\\\\\\\",\\\\\\\"ImageLength\\\\\\\",\\\\\\\"ImageWidth\\\\\\\",\\\\\\\"PhotometricInterpretation\\\\\\\",\\\\\\\"PlanarConfiguration\\\\\\\",\\\\\\\"ResolutionUnit\\\\\\\",\\\\\\\"SamplesPerPixel\\\\\\\",\\\\\\\"XPosition\\\\\\\",\\\\\\\"YPosition\\\\\\\"].forEach(e=>{o[e]&&(o[e]=h(o[e]))});const p=c(o);return u(l,a,n,p)}\\\\n},{\\\\\\\"./globals\\\\\\\":\\\\\\\"j27V\\\\\\\",\\\\\\\"./utils\\\\\\\":\\\\\\\"FOZT\\\\\\\"}],\\\\\\\"bsJs\\\\\\\":[function(require,module,exports) {\\\\n\\\\\\\"use strict\\\\\\\";Object.defineProperty(exports,\\\\\\\"__esModule\\\\\\\",{value:!0}),exports.fromUrl=w,exports.fromArrayBuffer=F,exports.fromFile=D,exports.fromBlob=I,exports.fromUrls=b,exports.writeArrayBuffer=m,Object.defineProperty(exports,\\\\\\\"Pool\\\\\\\",{enumerable:!0,get:function(){return r.default}}),exports.rgb=exports.globals=exports.MultiGeoTIFF=exports.default=exports.GeoTIFF=void 0;var e=c(require(\\\\\\\"./geotiffimage\\\\\\\")),i=c(require(\\\\\\\"./dataview64\\\\\\\")),t=c(require(\\\\\\\"./dataslice\\\\\\\")),r=c(require(\\\\\\\"./pool\\\\\\\")),s=require(\\\\\\\"./source\\\\\\\"),a=f(require(\\\\\\\"./globals\\\\\\\"));exports.globals=a;var n=require(\\\\\\\"./geotiffwriter\\\\\\\"),l=f(require(\\\\\\\"./rgb\\\\\\\"));function o(){if(\\\\\\\"function\\\\\\\"!=typeof WeakMap)return null;var e=new WeakMap;return o=function(){return e},e}function f(e){if(e&&e.__esModule)return e;if(null===e||\\\\\\\"object\\\\\\\"!=typeof e&&\\\\\\\"function\\\\\\\"!=typeof e)return{default:e};var i=o();if(i&&i.has(e))return i.get(e);var t={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if(Object.prototype.hasOwnProperty.call(e,s)){var a=r?Object.getOwnPropertyDescriptor(e,s):null;a&&(a.get||a.set)?Object.defineProperty(t,s,a):t[s]=e[s]}return t.default=e,i&&i.set(e,t),t}function c(e){return e&&e.__esModule?e:{default:e}}function u(e){switch(e){case a.fieldTypes.BYTE:case a.fieldTypes.ASCII:case a.fieldTypes.SBYTE:case a.fieldTypes.UNDEFINED:return 1;case a.fieldTypes.SHORT:case a.fieldTypes.SSHORT:return 2;case a.fieldTypes.LONG:case a.fieldTypes.SLONG:case a.fieldTypes.FLOAT:case a.fieldTypes.IFD:return 4;case a.fieldTypes.RATIONAL:case a.fieldTypes.SRATIONAL:case a.fieldTypes.DOUBLE:case a.fieldTypes.LONG8:case a.fieldTypes.SLONG8:case a.fieldTypes.IFD8:return 8;default:throw new RangeError(`Invalid field type: ${e}`)}}function h(e){const i=e.GeoKeyDirectory;if(!i)return null;const t={};for(let r=4;r<=4*i[3];r+=4){const s=a.geoKeyNames[i[r]],n=i[r+1]?a.fieldTagNames[i[r+1]]:null,l=i[r+2],o=i[r+3];let f=null;if(n){if(null==(f=e[n]))throw new Error(`Could not get value of geoKey '${s}'.`);\\\\\\\"string\\\\\\\"==typeof f?f=f.substring(o,o+l-1):f.subarray&&(f=f.subarray(o,o+l-1))}else f=o;t[s]=f}return t}function d(e,i,t,r){let s=null,n=null;const l=u(i);switch(i){case a.fieldTypes.BYTE:case a.fieldTypes.ASCII:case a.fieldTypes.UNDEFINED:s=new Uint8Array(t),n=e.readUint8;break;case a.fieldTypes.SBYTE:s=new Int8Array(t),n=e.readInt8;break;case a.fieldTypes.SHORT:s=new Uint16Array(t),n=e.readUint16;break;case a.fieldTypes.SSHORT:s=new Int16Array(t),n=e.readInt16;break;case a.fieldTypes.LONG:case a.fieldTypes.IFD:s=new Uint32Array(t),n=e.readUint32;break;case a.fieldTypes.SLONG:s=new Int32Array(t),n=e.readInt32;break;case a.fieldTypes.LONG8:case a.fieldTypes.IFD8:s=new Array(t),n=e.readUint64;break;case a.fieldTypes.SLONG8:s=new Array(t),n=e.readInt64;break;case a.fieldTypes.RATIONAL:s=new Uint32Array(2*t),n=e.readUint32;break;case a.fieldTypes.SRATIONAL:s=new Int32Array(2*t),n=e.readInt32;break;case a.fieldTypes.FLOAT:s=new Float32Array(t),n=e.readFloat32;break;case a.fieldTypes.DOUBLE:s=new Float64Array(t),n=e.readFloat64;break;default:throw new RangeError(`Invalid field type: ${i}`)}if(i!==a.fieldTypes.RATIONAL&&i!==a.fieldTypes.SRATIONAL)for(let a=0;a<t;++a)s[a]=n.call(e,r+a*l);else for(let a=0;a<t;a+=2)s[a]=n.call(e,r+a*l),s[a+1]=n.call(e,r+(a*l+4));return i===a.fieldTypes.ASCII?String.fromCharCode.apply(null,s):s}exports.rgb=l;class g{async readRasters(e={}){const{window:i,width:t,height:r}=e;let{resX:s,resY:a,bbox:n}=e;const l=await this.getImage();let o=l;const f=await this.getImageCount(),c=l.getBoundingBox();if(i&&n)throw new Error('Both \\\\\\\"bbox\\\\\\\" and \\\\\\\"window\\\\\\\" passed.');if(t||r){if(i){const[e,t]=l.getOrigin(),[r,s]=l.getResolution();n=[e+i[0]*r,t+i[1]*s,e+i[2]*r,t+i[3]*s]}const e=n||c;if(t){if(s)throw new Error(\\\\\\\"Both width and resX passed\\\\\\\");s=(e[2]-e[0])/t}if(r){if(a)throw new Error(\\\\\\\"Both width and resY passed\\\\\\\");a=(e[3]-e[1])/r}}if(s||a){const e=[];for(let i=0;i<f;++i){const t=await this.getImage(i),{SubfileType:r,NewSubfileType:s}=t.fileDirectory;(0===i||2===r||1&s)&&e.push(t)}e.sort((e,i)=>e.getWidth()-i.getWidth());for(let i=0;i<e.length;++i){const t=e[i],r=(c[2]-c[0])/t.getWidth(),n=(c[3]-c[1])/t.getHeight();if(o=t,s&&s>r||a&&a>n)break}}let u=i;if(n){const[e,i]=l.getOrigin(),[t,r]=o.getResolution(l);u=[Math.round((n[0]-e)/t),Math.round((n[1]-i)/r),Math.round((n[2]-e)/t),Math.round((n[3]-i)/r)],u=[Math.min(u[0],u[2]),Math.min(u[1],u[3]),Math.max(u[0],u[2]),Math.max(u[1],u[3])]}return o.readRasters({...e,window:u})}}class p extends g{constructor(e,i,t,r,s={}){super(),this.source=e,this.littleEndian=i,this.bigTiff=t,this.firstIFDOffset=r,this.cache=s.cache||!1,this.fileDirectories=null,this.fileDirectoriesParsing=null,this.ghostValues=null}async getSlice(e,i){const r=this.bigTiff?4048:1024;return new t.default(await this.source.fetch(e,void 0!==i?i:r),e,this.littleEndian,this.bigTiff)}async parseFileDirectories(){let e=this.firstIFDOffset;const i=this.bigTiff?8:2,t=this.bigTiff?20:12,r=[];for(;0!==e;){let s=await this.getSlice(e);const n=this.bigTiff?s.readUint64(e):s.readUint16(e),l=n*t+(this.bigTiff?16:6);s.covers(e,l)||(s=await this.getSlice(e,l));const o={};let f=e+(this.bigTiff?8:2);for(let e=0;e<n;f+=t,++e){const e=s.readUint16(f),i=s.readUint16(f+2),t=this.bigTiff?s.readUint64(f+4):s.readUint32(f+4);let r,n;const l=u(i),c=f+(this.bigTiff?12:8);if(l*t<=(this.bigTiff?8:4))r=d(s,i,t,c);else{const e=s.readOffset(c),a=u(i)*t;if(s.covers(e,a))r=d(s,i,t,e);else{r=d(await this.getSlice(e,a),i,t,e)}}n=1===t&&-1===a.arrayFields.indexOf(e)&&i!==a.fieldTypes.RATIONAL&&i!==a.fieldTypes.SRATIONAL?r[0]:r,o[a.fieldTagNames[e]]=n}r.push([o,h(o)]),e=s.readOffset(e+i+t*n)}return r}async getImage(i=0){this.fileDirectories||(this.fileDirectoriesParsing||(this.fileDirectoriesParsing=this.parseFileDirectories()),this.fileDirectories=await this.fileDirectoriesParsing);const t=this.fileDirectories[i];if(!t)throw new RangeError(\\\\\\\"Invalid image index\\\\\\\");return new e.default(t[0],t[1],this.dataView,this.littleEndian,this.cache,this.source)}async getImageCount(){return this.fileDirectories||(this.fileDirectoriesParsing||(this.fileDirectoriesParsing=this.parseFileDirectories()),this.fileDirectories=await this.fileDirectoriesParsing),this.fileDirectories.length}async getGhostValues(){const e=this.bigTiff?16:8;if(this.ghostValues)return this.ghostValues;const i=\\\\\\\"GDAL_STRUCTURAL_METADATA_SIZE=\\\\\\\",t=i.length+100;let r=await this.getSlice(e,t);if(i===d(r,a.fieldTypes.ASCII,i.length,e)){const i=d(r,a.fieldTypes.ASCII,t,e).split(\\\\\\\"\\\\\\\\n\\\\\\\")[0],s=Number(i.split(\\\\\\\"=\\\\\\\")[1].split(\\\\\\\" \\\\\\\")[0])+i.length;s>t&&(r=await this.getSlice(e,s));const n=d(r,a.fieldTypes.ASCII,s,e);this.ghostValues={},n.split(\\\\\\\"\\\\\\\\n\\\\\\\").filter(e=>e.length>0).map(e=>e.split(\\\\\\\"=\\\\\\\")).forEach(([e,i])=>{this.ghostValues[e]=i})}return this.ghostValues}static async fromSource(e,t){const r=await e.fetch(0,1024),s=new i.default(r),a=s.getUint16(0,0);let n;if(18761===a)n=!0;else{if(19789!==a)throw new TypeError(\\\\\\\"Invalid byte order value.\\\\\\\");n=!1}const l=s.getUint16(2,n);let o;if(42===l)o=!1;else{if(43!==l)throw new TypeError(\\\\\\\"Invalid magic number.\\\\\\\");if(o=!0,8!==s.getUint16(4,n))throw new Error(\\\\\\\"Unsupported offset byte-size.\\\\\\\")}const f=o?s.getUint64(8,n):s.getUint32(4,n);return new p(e,n,o,f,t)}close(){return\\\\\\\"function\\\\\\\"==typeof this.source.close&&this.source.close()}}exports.GeoTIFF=p;var y=p;exports.default=y;class T extends g{constructor(e,i){super(),this.mainFile=e,this.overviewFiles=i,this.imageFiles=[e].concat(i),this.fileDirectoriesPerFile=null,this.fileDirectoriesPerFileParsing=null,this.imageCount=null}async parseFileDirectoriesPerFile(){const e=[this.mainFile.parseFileDirectories()].concat(this.overviewFiles.map(e=>e.parseFileDirectories()));return this.fileDirectoriesPerFile=await Promise.all(e),this.fileDirectoriesPerFile}async getImage(i=0){this.fileDirectoriesPerFile||(this.fileDirectoriesPerFileParsing||(this.fileDirectoriesPerFileParsing=this.parseFileDirectoriesPerFile()),this.fileDirectoriesPerFile=await this.fileDirectoriesPerFileParsing);let t=i;for(let r=0;r<this.fileDirectoriesPerFile.length;++r){const i=this.fileDirectoriesPerFile[r];if(t<i.length){const s=this.imageFiles[r];return new e.default(i[t][0],i[t][1],s.dataView,s.littleEndian,s.cache,s.source)}t-=i.length}throw new RangeError(\\\\\\\"Invalid image index\\\\\\\")}async getImageCount(){return this.fileDirectoriesPerFile||(this.fileDirectoriesPerFileParsing||(this.fileDirectoriesPerFileParsing=this.parseFileDirectoriesPerFile()),this.fileDirectoriesPerFile=await this.fileDirectoriesPerFileParsing),this.fileDirectoriesPerFile.reduce((e,i)=>e+i.length,0)}}async function w(e,i={}){return p.fromSource((0,s.makeRemoteSource)(e,i))}async function F(e){return p.fromSource((0,s.makeBufferSource)(e))}async function D(e){return p.fromSource((0,s.makeFileSource)(e))}async function I(e){return p.fromSource((0,s.makeFileReaderSource)(e))}async function b(e,i=[],t={}){const r=await p.fromSource((0,s.makeRemoteSource)(e,t)),a=await Promise.all(i.map(e=>p.fromSource((0,s.makeRemoteSource)(e,t))));return new T(r,a)}async function m(e,i){return(0,n.writeGeotiff)(e,i)}exports.MultiGeoTIFF=T;\\\\n},{\\\\\\\"./geotiffimage\\\\\\\":\\\\\\\"eOWo\\\\\\\",\\\\\\\"./dataview64\\\\\\\":\\\\\\\"dqpX\\\\\\\",\\\\\\\"./dataslice\\\\\\\":\\\\\\\"dGLV\\\\\\\",\\\\\\\"./pool\\\\\\\":\\\\\\\"dHPO\\\\\\\",\\\\\\\"./source\\\\\\\":\\\\\\\"cUx7\\\\\\\",\\\\\\\"./globals\\\\\\\":\\\\\\\"j27V\\\\\\\",\\\\\\\"./geotiffwriter\\\\\\\":\\\\\\\"BGyE\\\\\\\",\\\\\\\"./rgb\\\\\\\":\\\\\\\"fpBl\\\\\\\"}],\\\\\\\"epB2\\\\\\\":[function(require,module,exports) {\\\\n\\\\\\\"use strict\\\\\\\";Object.defineProperty(exports,\\\\\\\"__esModule\\\\\\\",{value:!0});var e=require(\\\\\\\"./geotiff\\\\\\\");Object.keys(e).forEach(function(t){\\\\\\\"default\\\\\\\"!==t&&\\\\\\\"__esModule\\\\\\\"!==t&&Object.defineProperty(exports,t,{enumerable:!0,get:function(){return e[t]}})});\\\\n},{\\\\\\\"./geotiff\\\\\\\":\\\\\\\"bsJs\\\\\\\"}]},{},[\\\\\\\"epB2\\\\\\\"], null)\\\\n//# sourceMappingURL=/main.js.map\\\\n\\\\n//# sourceURL=webpack://GeoRaster/./node_modules/geotiff/dist-node/main.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./src/parseData.js\\\":\\n/*!**************************!*\\\\\\n  !*** ./src/parseData.js ***!\\n  \\\\**************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"\\\\n\\\\nObject.defineProperty(exports, \\\\\\\"__esModule\\\\\\\", {\\\\n  value: true\\\\n});\\\\n\\\\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\\\\\\\"return\\\\\\\"]) _i[\\\\\\\"return\\\\\\\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\\\\\\\"Invalid attempt to destructure non-iterable instance\\\\\\\"); } }; }();\\\\n\\\\nvar _typeof = typeof Symbol === \\\\\\\"function\\\\\\\" && typeof Symbol.iterator === \\\\\\\"symbol\\\\\\\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \\\\\\\"function\\\\\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\\\\\"symbol\\\\\\\" : typeof obj; };\\\\n\\\\nexports.default = parseData;\\\\n\\\\nvar _geotiff = __webpack_require__(/*! geotiff */ \\\\\\\"./node_modules/geotiff/dist-node/main.js\\\\\\\");\\\\n\\\\nvar _utils = __webpack_require__(/*! ./utils.js */ \\\\\\\"./src/utils.js\\\\\\\");\\\\n\\\\nfunction processResult(result, debug) {\\\\n  var noDataValue = result.noDataValue;\\\\n  var height = result.height;\\\\n  var width = result.width;\\\\n\\\\n  return new Promise(function (resolve, reject) {\\\\n    result.maxs = [];\\\\n    result.mins = [];\\\\n    result.ranges = [];\\\\n\\\\n    var max = void 0;var min = void 0;\\\\n\\\\n    // console.log(\\\\\\\"starting to get min, max and ranges\\\\\\\");\\\\n    for (var rasterIndex = 0; rasterIndex < result.numberOfRasters; rasterIndex++) {\\\\n      var rows = result.values[rasterIndex];\\\\n      if (debug) console.log('[georaster] rows:', rows);\\\\n\\\\n      for (var rowIndex = 0; rowIndex < height; rowIndex++) {\\\\n        var row = rows[rowIndex];\\\\n\\\\n        for (var columnIndex = 0; columnIndex < width; columnIndex++) {\\\\n          var value = row[columnIndex];\\\\n          if (value != noDataValue && !isNaN(value)) {\\\\n            if (typeof min === 'undefined' || value < min) min = value;else if (typeof max === 'undefined' || value > max) max = value;\\\\n          }\\\\n        }\\\\n      }\\\\n\\\\n      result.maxs.push(max);\\\\n      result.mins.push(min);\\\\n      result.ranges.push(max - min);\\\\n    }\\\\n\\\\n    resolve(result);\\\\n  });\\\\n}\\\\n\\\\n/* We're not using async because trying to avoid dependency on babel's polyfill\\\\nThere can be conflicts when GeoRaster is used in another project that is also\\\\nusing @babel/polyfill */\\\\nfunction parseData(data, debug) {\\\\n  return new Promise(function (resolve, reject) {\\\\n    try {\\\\n      if (debug) console.log('starting parseData with', data);\\\\n      if (debug) console.log('\\\\\\\\tGeoTIFF:', typeof GeoTIFF === 'undefined' ? 'undefined' : _typeof(GeoTIFF));\\\\n\\\\n      var result = {};\\\\n\\\\n      var height = void 0,\\\\n          width = void 0;\\\\n\\\\n      if (data.rasterType === 'object') {\\\\n        result.values = data.data;\\\\n        result.height = height = data.metadata.height || result.values[0].length;\\\\n        result.width = width = data.metadata.width || result.values[0][0].length;\\\\n        result.pixelHeight = data.metadata.pixelHeight;\\\\n        result.pixelWidth = data.metadata.pixelWidth;\\\\n        result.projection = data.metadata.projection;\\\\n        result.xmin = data.metadata.xmin;\\\\n        result.ymax = data.metadata.ymax;\\\\n        result.noDataValue = data.metadata.noDataValue;\\\\n        result.numberOfRasters = result.values.length;\\\\n        result.xmax = result.xmin + result.width * result.pixelWidth;\\\\n        result.ymin = result.ymax - result.height * result.pixelHeight;\\\\n        result._data = null;\\\\n        resolve(processResult(result));\\\\n      } else if (data.rasterType === 'geotiff') {\\\\n        result._data = data.data;\\\\n\\\\n        var initFunction = _geotiff.fromArrayBuffer;\\\\n        if (data.sourceType === 'url') {\\\\n          initFunction = _geotiff.fromUrl;\\\\n        }\\\\n\\\\n        if (debug) console.log('data.rasterType is geotiff');\\\\n        resolve(initFunction(data.data).then(function (geotiff) {\\\\n          if (debug) console.log('geotiff:', geotiff);\\\\n          return geotiff.getImage().then(function (image) {\\\\n            if (debug) console.log('image:', image);\\\\n\\\\n            var fileDirectory = image.fileDirectory;\\\\n\\\\n            var _image$getGeoKeys = image.getGeoKeys(),\\\\n                GeographicTypeGeoKey = _image$getGeoKeys.GeographicTypeGeoKey,\\\\n                ProjectedCSTypeGeoKey = _image$getGeoKeys.ProjectedCSTypeGeoKey;\\\\n\\\\n            result.projection = GeographicTypeGeoKey || ProjectedCSTypeGeoKey;\\\\n            if (debug) console.log('projection:', result.projection);\\\\n\\\\n            result.height = height = image.getHeight();\\\\n            if (debug) console.log('result.height:', result.height);\\\\n            result.width = width = image.getWidth();\\\\n            if (debug) console.log('result.width:', result.width);\\\\n\\\\n            var _image$getResolution = image.getResolution(),\\\\n                _image$getResolution2 = _slicedToArray(_image$getResolution, 2),\\\\n                resolutionX = _image$getResolution2[0],\\\\n                resolutionY = _image$getResolution2[1];\\\\n\\\\n            result.pixelHeight = Math.abs(resolutionY);\\\\n            result.pixelWidth = Math.abs(resolutionX);\\\\n\\\\n            var _image$getOrigin = image.getOrigin(),\\\\n                _image$getOrigin2 = _slicedToArray(_image$getOrigin, 2),\\\\n                originX = _image$getOrigin2[0],\\\\n                originY = _image$getOrigin2[1];\\\\n\\\\n            result.xmin = originX;\\\\n            result.xmax = result.xmin + width * result.pixelWidth;\\\\n            result.ymax = originY;\\\\n            result.ymin = result.ymax - height * result.pixelHeight;\\\\n\\\\n            result.noDataValue = fileDirectory.GDAL_NODATA ? parseFloat(fileDirectory.GDAL_NODATA) : null;\\\\n\\\\n            result.numberOfRasters = fileDirectory.SamplesPerPixel;\\\\n\\\\n            if (data.sourceType !== 'url') {\\\\n              return image.readRasters().then(function (rasters) {\\\\n                result.values = rasters.map(function (valuesInOneDimension) {\\\\n                  return (0, _utils.unflatten)(valuesInOneDimension, { height: height, width: width });\\\\n                });\\\\n                return processResult(result);\\\\n              });\\\\n            } else {\\\\n              return result;\\\\n            }\\\\n          });\\\\n        }));\\\\n      }\\\\n    } catch (error) {\\\\n      reject(error);\\\\n      console.error('[georaster] error parsing georaster:', error);\\\\n    }\\\\n  });\\\\n}\\\\n\\\\n//# sourceURL=webpack://GeoRaster/./src/parseData.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./src/utils.js\\\":\\n/*!**********************!*\\\\\\n  !*** ./src/utils.js ***!\\n  \\\\**********************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"\\\\n\\\\nfunction countIn1D(array) {\\\\n  return array.reduce(function (counts, value) {\\\\n    if (counts[value] === undefined) {\\\\n      counts[value] = 1;\\\\n    } else {\\\\n      counts[value]++;\\\\n    }\\\\n    return counts;\\\\n  }, {});\\\\n}\\\\n\\\\nfunction countIn2D(rows) {\\\\n  return rows.reduce(function (counts, values) {\\\\n    values.forEach(function (value) {\\\\n      if (counts[value] === undefined) {\\\\n        counts[value] = 1;\\\\n      } else {\\\\n        counts[value]++;\\\\n      }\\\\n    });\\\\n    return counts;\\\\n  }, {});\\\\n}\\\\n\\\\n/*\\\\nTakes in a flattened one dimensional array\\\\nrepresenting two-dimensional pixel values\\\\nand returns an array of arrays.\\\\n*/\\\\nfunction unflatten(valuesInOneDimension, size) {\\\\n  var height = size.height,\\\\n      width = size.width;\\\\n\\\\n  var valuesInTwoDimensions = [];\\\\n  for (var y = 0; y < height; y++) {\\\\n    var start = y * width;\\\\n    var end = start + width;\\\\n    valuesInTwoDimensions.push(valuesInOneDimension.slice(start, end));\\\\n  }\\\\n  return valuesInTwoDimensions;\\\\n}\\\\n\\\\nmodule.exports = { countIn1D: countIn1D, countIn2D: countIn2D, unflatten: unflatten };\\\\n\\\\n//# sourceURL=webpack://GeoRaster/./src/utils.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./src/worker.js\\\":\\n/*!***********************!*\\\\\\n  !*** ./src/worker.js ***!\\n  \\\\***********************/\\n/*! no exports provided */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"__webpack_require__.r(__webpack_exports__);\\\\n/* harmony import */ var _parseData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parseData.js */ \\\\\\\"./src/parseData.js\\\\\\\");\\\\n/* harmony import */ var _parseData_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_parseData_js__WEBPACK_IMPORTED_MODULE_0__);\\\\n\\\\n\\\\n// this is a bit of a hack to trick geotiff to work with web worker\\\\n// eslint-disable-next-line no-unused-vars\\\\nconst window = self;\\\\n\\\\nonmessage = e => {\\\\n  const data = e.data;\\\\n  _parseData_js__WEBPACK_IMPORTED_MODULE_0___default()(data).then(result => {\\\\n    if (result._data instanceof ArrayBuffer) {\\\\n      postMessage(result, [result._data]);\\\\n    } else {\\\\n      postMessage(result);\\\\n    }\\\\n    close();\\\\n  });\\\\n};\\\\n\\\\n\\\\n//# sourceURL=webpack://GeoRaster/./src/worker.js?\\\");\\n\\n/***/ })\\n\\n/******/ });\", null);\n};\n\n//# sourceURL=webpack://GeoRaster/./src/worker.js?");

/***/ }),

/***/ "node-fetch":
/*!*****************************!*\
  !*** external "node-fetch" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_node_fetch__;\n\n//# sourceURL=webpack://GeoRaster/external_%22node-fetch%22?");

/***/ })

/******/ });
});